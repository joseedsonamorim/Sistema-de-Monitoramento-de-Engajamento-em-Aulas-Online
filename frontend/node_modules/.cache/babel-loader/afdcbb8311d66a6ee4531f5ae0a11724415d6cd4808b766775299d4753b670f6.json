{"ast":null,"code":"// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n  }\n  async initialize() {\n    if (this.isInitialized) return;\n\n    // Dynamically load MediaPipe scripts\n    await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh');\n    await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils');\n    if (typeof window !== 'undefined' && window.FaceMesh) {\n      this.faceMesh = new window.FaceMesh({\n        locateFile: file => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n      this.faceMesh.onResults(results => {\n        this.processResults(results);\n      });\n      this.isInitialized = true;\n    }\n  }\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  }\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n  calculateEAR(landmarks) {\n    // Índices dos pontos do olho esquerdo (usados para cálculo EAR)\n    // const leftEye = [\n    //   landmarks[33], landmarks[7], landmarks[163], landmarks[144],\n    //   landmarks[145], landmarks[153], landmarks[154], landmarks[155]\n    // ];\n\n    // Índices dos pontos do olho direito (usados para cálculo EAR)\n    // const rightEye = [\n    //   landmarks[362], landmarks[382], landmarks[381], landmarks[380],\n    //   landmarks[374], landmarks[373], landmarks[390], landmarks[249]\n    // ];\n\n    const leftEAR = this.getEyeAspectRatio([landmarks[33], landmarks[133], landmarks[157], landmarks[158], landmarks[159], landmarks[160]]);\n    const rightEAR = this.getEyeAspectRatio([landmarks[362], landmarks[385], landmarks[386], landmarks[387], landmarks[388], landmarks[466]]);\n    return (leftEAR + rightEAR) / 2;\n  }\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    return mouthOpening;\n  }\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n    return {\n      x: gazeX,\n      y: gazeY\n    };\n  }\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n    return Math.min(fatigue, 1.0);\n  }\n  distance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n  }\n  async start() {\n    try {\n      console.log('Iniciando sistema de detecção facial...');\n      await this.initialize();\n      if (!this.faceMesh) {\n        console.error('MediaPipe não carregado, usando modo simulado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n        return;\n      }\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        console.error('Elemento de vídeo não encontrado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n        return;\n      }\n      if (window.Camera) {\n        console.log('Iniciando câmera com MediaPipe...');\n        this.camera = new window.Camera(videoElement, {\n          onFrame: async () => {\n            if (this.faceMesh) {\n              await this.faceMesh.send({\n                image: videoElement\n              });\n            }\n          },\n          width: 640,\n          height: 480\n        });\n        await this.camera.start();\n        console.log('Câmera iniciada com sucesso');\n        if (this.onReady) {\n          this.onReady();\n        }\n      } else {\n        console.log('Camera API não disponível, usando modo simulado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n      console.log('Usando modo simulado devido ao erro');\n      this.simulateDetection();\n      if (this.onReady) {\n        this.onReady();\n      }\n    }\n  }\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? 1.0 - fatigueScore * 0.5 : 0.0\n      });\n    }, 2000);\n  }\n  stop() {\n    if (this.camera) {\n      this.camera.stop();\n    }\n    if (this.simulationInterval) {\n      clearInterval(this.simulationInterval);\n    }\n  }\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}","map":{"version":3,"names":["FaceDetectionSystem","constructor","onDetectionUpdate","onReady","lastBlinkTime","earHistory","blinkCount","yawnCount","lastYawnTime","eyeOpenTime","stressScore","gazeOffScreen","faceMesh","camera","isInitialized","initialize","loadScript","window","FaceMesh","locateFile","file","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","processResults","src","Promise","resolve","reject","script","document","createElement","onload","onerror","head","appendChild","multiFaceLandmarks","length","faceDetected","gazeOnScreen","fatigueScore","landmarks","eyeAspectRatio","calculateEAR","yawnRatio","calculateYawnRatio","gazeDirection","estimateGaze","currentTime","Date","now","calculateFatigue","isGazeOnScreen","x","y","Math","min","attentionScore","leftEAR","getEyeAspectRatio","rightEAR","eyePoints","verticalDist1","distance","verticalDist2","horizontalDist","mouthTop","mouthBottom","mouthOpening","abs","noseTip","leftEyeCenter","rightEyeCenter","gazeX","gazeY","EAR","fatigue","point1","point2","sqrt","pow","start","console","log","error","simulateDetection","videoElement","getElementById","Camera","onFrame","send","image","width","height","simulationInterval","setInterval","random","blinkIncrement","floor","stop","clearInterval","resetCounters"],"sources":["/Users/macbookair/Documents/GitHub/Sistema-de-Monitoramento-de-Engajamento-em-Aulas-Online/frontend/src/utils/FaceDetection.js"],"sourcesContent":["// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    // Dynamically load MediaPipe scripts\n    await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh');\n    await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils');\n\n    if (typeof window !== 'undefined' && window.FaceMesh) {\n      this.faceMesh = new window.FaceMesh({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n\n      this.faceMesh.onResults((results) => {\n        this.processResults(results);\n      });\n\n      this.isInitialized = true;\n    }\n  }\n\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  }\n\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && \n                           gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    \n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n\n  calculateEAR(landmarks) {\n    // Índices dos pontos do olho esquerdo (usados para cálculo EAR)\n    // const leftEye = [\n    //   landmarks[33], landmarks[7], landmarks[163], landmarks[144],\n    //   landmarks[145], landmarks[153], landmarks[154], landmarks[155]\n    // ];\n\n    // Índices dos pontos do olho direito (usados para cálculo EAR)\n    // const rightEye = [\n    //   landmarks[362], landmarks[382], landmarks[381], landmarks[380],\n    //   landmarks[374], landmarks[373], landmarks[390], landmarks[249]\n    // ];\n\n    const leftEAR = this.getEyeAspectRatio([\n      landmarks[33], landmarks[133], landmarks[157], \n      landmarks[158], landmarks[159], landmarks[160]\n    ]);\n    \n    const rightEAR = this.getEyeAspectRatio([\n      landmarks[362], landmarks[385], landmarks[386],\n      landmarks[387], landmarks[388], landmarks[466]\n    ]);\n\n    return (leftEAR + rightEAR) / 2;\n  }\n\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    \n    return mouthOpening;\n  }\n\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n\n    return { x: gazeX, y: gazeY };\n  }\n\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;\n    else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;\n    else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n\n    return Math.min(fatigue, 1.0);\n  }\n\n  distance(point1, point2) {\n    return Math.sqrt(\n      Math.pow(point1.x - point2.x, 2) + \n      Math.pow(point1.y - point2.y, 2)\n    );\n  }\n\n  async start() {\n    try {\n      console.log('Iniciando sistema de detecção facial...');\n      await this.initialize();\n\n      if (!this.faceMesh) {\n        console.error('MediaPipe não carregado, usando modo simulado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n        return;\n      }\n\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        console.error('Elemento de vídeo não encontrado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n        return;\n      }\n\n      if (window.Camera) {\n        console.log('Iniciando câmera com MediaPipe...');\n        this.camera = new window.Camera(videoElement, {\n          onFrame: async () => {\n            if (this.faceMesh) {\n              await this.faceMesh.send({ image: videoElement });\n            }\n          },\n          width: 640,\n          height: 480\n        });\n\n        await this.camera.start();\n        console.log('Câmera iniciada com sucesso');\n\n        if (this.onReady) {\n          this.onReady();\n        }\n      } else {\n        console.log('Camera API não disponível, usando modo simulado');\n        this.simulateDetection();\n        if (this.onReady) {\n          this.onReady();\n        }\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n      console.log('Usando modo simulado devido ao erro');\n      this.simulateDetection();\n      if (this.onReady) {\n        this.onReady();\n      }\n    }\n  }\n\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? (1.0 - fatigueScore * 0.5) : 0.0\n      });\n    }, 2000);\n  }\n\n  stop() {\n    if (this.camera) {\n      this.camera.stop();\n    }\n    if (this.simulationInterval) {\n      clearInterval(this.simulationInterval);\n    }\n  }\n\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}