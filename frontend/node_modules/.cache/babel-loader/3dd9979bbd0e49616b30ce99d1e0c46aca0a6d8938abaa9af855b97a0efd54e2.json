{"ast":null,"code":"// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n    this.stream = null;\n    this.isRunning = false;\n    this.healthCheckInterval = null;\n    this.isReconnecting = false; // Flag para prevenir reconexões múltiplas\n\n    // NOTA: Não iniciar health check aqui - será iniciado após a câmera estar rodando\n  }\n  startHealthCheck() {\n    this.healthCheckInterval = setInterval(async () => {\n      // Não fazer nada se já estiver reconectando ou não estiver rodando\n      if (this.isReconnecting || !this.isRunning) {\n        return;\n      }\n      const videoElement = document.getElementById('input_video');\n\n      // Verificar se o elemento existe e tem stream\n      if (!videoElement || !videoElement.srcObject) {\n        console.warn('Stream de vídeo não encontrado');\n        return;\n      }\n\n      // Verificar estado do vídeo de forma mais tolerante\n      const tracks = videoElement.srcObject.getVideoTracks();\n      if (tracks.length === 0 || tracks[0].readyState === 'ended') {\n        console.warn('Track de vídeo foi finalizada, tentando reconectar...');\n\n        // Prevenir múltiplas reconexões simultâneas\n        if (this.isReconnecting) {\n          return;\n        }\n        this.isReconnecting = true;\n        try {\n          // Parar tudo antes de reconectar\n          const wasRunning = this.isRunning;\n          await this.stop();\n\n          // Aguardar um pouco antes de reconectar\n          await new Promise(resolve => setTimeout(resolve, 2000));\n\n          // Se estava rodando antes, reconectar\n          if (wasRunning) {\n            await this.start();\n          }\n        } catch (error) {\n          console.error('Falha ao reconectar câmera:', error);\n          this.isRunning = false;\n        } finally {\n          this.isReconnecting = false;\n        }\n      } else if (videoElement.readyState < 2) {\n        // readyState < 2 significa que o vídeo ainda está carregando\n        // Isso é normal, não precisa reconectar\n        console.log('Vídeo ainda carregando, readyState:', videoElement.readyState);\n      }\n    }, 10000); // Verificar a cada 10 segundos (menos agressivo)\n  }\n  async initialize() {\n    if (this.isInitialized) return;\n    try {\n      console.log('Iniciando carregamento do MediaPipe...');\n\n      // Verificar suporte do navegador\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Este navegador não suporta acesso à câmera');\n      }\n\n      // Carregar MediaPipe dinamicamente se ainda não estiver carregado\n      if (typeof window === 'undefined' || !window.FaceMesh || !window.Camera) {\n        console.log('Carregando MediaPipe dinamicamente...');\n\n        // Configurar Module ANTES de carregar para evitar erro Module.arguments\n        if (typeof window !== 'undefined') {\n          // Criar ou obter Module global\n          if (!window.Module) {\n            window.Module = {};\n          }\n\n          // Remover arguments se existir\n          if (window.Module.hasOwnProperty('arguments')) {\n            delete window.Module.arguments;\n          }\n\n          // Interceptar acesso a Module.arguments usando Proxy\n          // Isso permite que o código WASM acesse Module.arguments sem erro\n          try {\n            const originalModule = window.Module;\n\n            // Primeiro, definir arguments_ como propriedade não-enumerável\n            Object.defineProperty(originalModule, 'arguments_', {\n              value: [],\n              writable: true,\n              enumerable: false,\n              configurable: true\n            });\n\n            // Criar Proxy para interceptar acessos\n            window.Module = new Proxy(originalModule, {\n              get: function (target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar arguments_ em vez de arguments\n                  return target.arguments_ || [];\n                }\n                return target[prop];\n              },\n              set: function (target, prop, value) {\n                if (prop === 'arguments') {\n                  // Redirecionar para arguments_\n                  if (!target.arguments_) {\n                    target.arguments_ = [];\n                  }\n                  // Não definir arguments diretamente\n                  console.warn('Tentativa de definir Module.arguments redirecionada para arguments_');\n                  return true;\n                }\n                target[prop] = value;\n                return true;\n              },\n              has: function (target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar true mas redirecionar para arguments_\n                  return true;\n                }\n                return prop in target;\n              },\n              getOwnPropertyDescriptor: function (target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar descriptor para arguments_ em vez de arguments\n                  return Object.getOwnPropertyDescriptor(target, 'arguments_') || {\n                    value: target.arguments_ || [],\n                    writable: true,\n                    enumerable: false,\n                    configurable: true\n                  };\n                }\n                return Object.getOwnPropertyDescriptor(target, prop);\n              }\n            });\n            console.log('Module configurado com Proxy para evitar erro arguments');\n          } catch (proxyError) {\n            console.warn('Não foi possível criar Proxy para Module:', proxyError);\n            // Continuar mesmo sem Proxy, mas pelo menos garantir arguments_\n            if (window.Module && !window.Module.arguments_) {\n              window.Module.arguments_ = [];\n            }\n          }\n        }\n\n        // Carregar scripts do MediaPipe\n        const scripts = ['https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js', 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js'];\n\n        // Tentar carregar scripts um por um\n        for (const src of scripts) {\n          try {\n            await this.loadScript(src);\n            // Aguardar um pouco entre carregamentos\n            await new Promise(resolve => setTimeout(resolve, 500));\n\n            // Após carregar cada script, verificar e corrigir Module novamente\n            if (typeof window !== 'undefined' && window.Module) {\n              // Remover arguments se foi adicionado pelo script\n              if (window.Module.hasOwnProperty('arguments')) {\n                delete window.Module.arguments;\n              }\n\n              // Garantir que arguments_ existe (o novo nome esperado)\n              if (!window.Module.hasOwnProperty('arguments_')) {\n                window.Module.arguments_ = [];\n              }\n            }\n          } catch (error) {\n            console.warn(`Falha ao carregar ${src}, tentando alternativa...`);\n            // Tentar sem versão específica\n            const fallbackSrc = src.replace(/@[\\d.]+/g, '');\n            try {\n              await this.loadScript(fallbackSrc);\n              await new Promise(resolve => setTimeout(resolve, 500));\n\n              // Corrigir Module após fallback também\n              if (typeof window !== 'undefined' && window.Module) {\n                if (window.Module.hasOwnProperty('arguments')) {\n                  delete window.Module.arguments;\n                }\n                if (!window.Module.hasOwnProperty('arguments_')) {\n                  window.Module.arguments_ = [];\n                }\n              }\n            } catch (fallbackError) {\n              console.error(`Falha ao carregar alternativa: ${fallbackSrc}`);\n              throw new Error(`Não foi possível carregar MediaPipe: ${src}`);\n            }\n          }\n        }\n\n        // Aguardar até que o MediaPipe esteja disponível\n        let maxWaitAttempts = 30; // 3 segundos máximo (30 * 100ms)\n        let waitAttempt = 0;\n        while (typeof window === 'undefined' || !window.FaceMesh || !window.Camera) {\n          if (waitAttempt >= maxWaitAttempts) {\n            throw new Error('MediaPipe não foi carregado após tentativas.');\n          }\n          await new Promise(resolve => setTimeout(resolve, 100));\n          waitAttempt++;\n        }\n\n        // Última verificação e correção do Module após MediaPipe estar disponível\n        if (typeof window !== 'undefined' && window.Module) {\n          // Remover arguments se ainda existir\n          if (window.Module.hasOwnProperty('arguments')) {\n            delete window.Module.arguments;\n            console.log('Module.arguments removido após carregamento do MediaPipe');\n          }\n\n          // Garantir que arguments_ existe\n          if (!window.Module.hasOwnProperty('arguments_')) {\n            window.Module.arguments_ = [];\n            console.log('Module.arguments_ criado');\n          }\n        }\n      }\n      console.log('MediaPipe está disponível');\n\n      // Verificar se FaceMesh e Camera são realmente funções\n      if (typeof window.FaceMesh !== 'function') {\n        console.error('window.FaceMesh:', typeof window.FaceMesh, window.FaceMesh);\n        throw new Error('FaceMesh não é uma função. MediaPipe pode não estar carregado corretamente.');\n      }\n      if (typeof window.Camera !== 'function') {\n        console.error('window.Camera:', typeof window.Camera, window.Camera);\n        throw new Error('Camera não é uma função. MediaPipe pode não estar carregado corretamente.');\n      }\n\n      // Verificar se há um objeto MediaPipe global e suas propriedades\n      if (window.MediaPipe) {\n        console.log('MediaPipe global encontrado:', Object.keys(window.MediaPipe));\n      }\n\n      // Aguardar mais tempo para garantir que todos os módulos estão prontos\n      console.log('Aguardando MediaPipe estar completamente pronto...');\n      await new Promise(resolve => setTimeout(resolve, 1500));\n\n      // Verificação final e correção do Module antes de criar FaceMesh\n      if (typeof window !== 'undefined' && window.Module) {\n        // Garantir que não há arguments\n        if (window.Module.hasOwnProperty('arguments')) {\n          delete window.Module.arguments;\n          console.log('Module.arguments removido antes de criar FaceMesh');\n        }\n\n        // Garantir que arguments_ existe\n        if (!window.Module.hasOwnProperty('arguments_')) {\n          Object.defineProperty(window.Module, 'arguments_', {\n            value: [],\n            writable: true,\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n      console.log('Configurando FaceMesh...');\n\n      // Configurar FaceMesh com locateFile correto para CDN\n      // O MediaPipe precisa saber onde encontrar os arquivos WASM e outros recursos\n      // Vamos usar um objeto para rastrear tentativas e ter fallback\n      const locateFileCache = {};\n      const faceMeshOptions = {\n        locateFile: file => {\n          console.log('FaceMesh solicitando arquivo:', file);\n\n          // Se já tentamos este arquivo, retornar o cache\n          if (locateFileCache[file]) {\n            return locateFileCache[file];\n          }\n          const fileName = file.split('/').pop();\n\n          // Tentar unpkg primeiro (melhor para arquivos estáticos)\n          const unpkgUrl = `https://unpkg.com/@mediapipe/face_mesh@0.4.1633559619/${fileName}`;\n\n          // Fallback para jsdelivr se necessário\n          const jsdelivrUrl = `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${fileName}`;\n\n          // Usar unpkg como padrão (mais confiável para arquivos binários)\n          const url = unpkgUrl;\n          locateFileCache[file] = url;\n          console.log('Retornando URL do CDN:', url);\n          return url;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n      let faceMeshCreated = false;\n      let attempts = 0;\n      const maxAttempts = 3;\n      while (!faceMeshCreated && attempts < maxAttempts) {\n        try {\n          attempts++;\n          console.log(`Tentativa ${attempts} de criar FaceMesh...`);\n\n          // Verificar novamente se FaceMesh está disponível antes de tentar criar\n          if (typeof window.FaceMesh !== 'function') {\n            throw new Error('FaceMesh não está disponível como função');\n          }\n          this.faceMesh = new window.FaceMesh(faceMeshOptions);\n\n          // Verificar se a instância foi criada corretamente\n          if (!this.faceMesh) {\n            throw new Error('FaceMesh não foi criado - instância é null ou undefined');\n          }\n\n          // Verificar se o método initialize existe e é uma função\n          if (typeof this.faceMesh.initialize !== 'function') {\n            console.error('FaceMesh métodos disponíveis:', Object.keys(this.faceMesh));\n            throw new Error(`FaceMesh.initialize não é uma função (tipo: ${typeof this.faceMesh.initialize})`);\n          }\n          faceMeshCreated = true;\n          console.log('FaceMesh criado com sucesso');\n        } catch (error) {\n          const errorMsg = error.message || error.toString();\n          console.warn(`Erro ao criar FaceMesh (tentativa ${attempts}):`, errorMsg);\n          console.error('Stack trace:', error.stack);\n\n          // Se for o erro \"z is not a function\", tentar abordagem diferente\n          if (errorMsg.includes('z is not a function') || errorMsg.includes('is not a function')) {\n            console.warn('Erro de função não encontrada detectado. Tentando abordagem alternativa...');\n\n            // Tentar criar sem locateFile personalizado\n            try {\n              await new Promise(resolve => setTimeout(resolve, 1000));\n              const simpleOptions = {\n                maxNumFaces: 1,\n                refineLandmarks: true,\n                minDetectionConfidence: 0.5,\n                minTrackingConfidence: 0.5\n              };\n              this.faceMesh = new window.FaceMesh(simpleOptions);\n              if (this.faceMesh && typeof this.faceMesh.initialize === 'function') {\n                faceMeshCreated = true;\n                console.log('FaceMesh criado com opções simples');\n                break;\n              }\n            } catch (simpleError) {\n              console.warn('Tentativa com opções simples também falhou:', simpleError);\n            }\n          }\n          if (attempts >= maxAttempts && !faceMeshCreated) {\n            throw new Error(`Não foi possível criar FaceMesh após ${maxAttempts} tentativas: ${errorMsg}`);\n          }\n\n          // Aguardar antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 1000 * attempts));\n        }\n      }\n\n      // Aguardar antes de inicializar para garantir que tudo está pronto\n      await new Promise(resolve => setTimeout(resolve, 500));\n      try {\n        console.log('Inicializando FaceMesh...');\n        await this.faceMesh.initialize();\n        console.log('FaceMesh inicializado com sucesso');\n      } catch (initError) {\n        console.error('Erro ao inicializar FaceMesh:', initError);\n\n        // Tentar limpar e reinicializar uma vez\n        try {\n          if (this.faceMesh && typeof this.faceMesh.close === 'function') {\n            await this.faceMesh.close();\n          }\n\n          // Aguardar antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 1500));\n\n          // Tentar criar uma nova instância\n          this.faceMesh = new window.FaceMesh(faceMeshOptions);\n          await new Promise(resolve => setTimeout(resolve, 500));\n          await this.faceMesh.initialize();\n          console.log('FaceMesh reinicializado com sucesso');\n        } catch (retryError) {\n          console.error('Falha ao reinicializar FaceMesh:', retryError);\n          throw new Error(`Erro ao inicializar FaceMesh: ${initError.message}. Tentativa de recuperação falhou: ${retryError.message}`);\n        }\n      }\n      this.faceMesh.onResults(results => {\n        this.processResults(results);\n      });\n      console.log('FaceMesh configurado com sucesso');\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Erro na inicialização:', error);\n      throw error;\n    }\n  }\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      // Verificar se o script já foi carregado\n      const existingScript = Array.from(document.querySelectorAll('script')).find(s => s.src === src || s.src.includes(src.split('/').pop()));\n      if (existingScript && (window.FaceMesh || window.Camera)) {\n        console.log('Script já carregado:', src);\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = src;\n      script.crossOrigin = 'anonymous';\n      script.async = true;\n\n      // Verificar se o conteúdo carregado é JavaScript válido\n      script.onload = () => {\n        // Verificar se não é uma página de erro HTML\n        if (window.FaceMesh || window.Camera || src.includes('face_mesh') || src.includes('camera_utils')) {\n          console.log('Script carregado com sucesso:', src);\n          resolve();\n        } else {\n          // Aguardar um pouco mais antes de considerar erro\n          setTimeout(() => {\n            if (window.FaceMesh || window.Camera) {\n              resolve();\n            } else {\n              reject(new Error(`Script ${src} não carregou corretamente (possível erro HTML)`));\n            }\n          }, 1000);\n        }\n      };\n      script.onerror = error => {\n        console.error('Erro ao carregar script:', src, error);\n        reject(new Error(`Falha ao carregar ${src}. Verifique se a URL está correta e acessível.`));\n      };\n      document.head.appendChild(script);\n    });\n  }\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n  calculateEAR(landmarks) {\n    try {\n      const leftEAR = this.getEyeAspectRatio([landmarks[33], landmarks[133], landmarks[157], landmarks[158], landmarks[159], landmarks[160]]);\n      const rightEAR = this.getEyeAspectRatio([landmarks[362], landmarks[385], landmarks[386], landmarks[387], landmarks[388], landmarks[466]]);\n      return (leftEAR + rightEAR) / 2;\n    } catch (error) {\n      console.warn('Erro ao calcular EAR:', error);\n      return 0.3; // valor padrão seguro\n    }\n  }\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    return mouthOpening;\n  }\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n    return {\n      x: gazeX,\n      y: gazeY\n    };\n  }\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n    return Math.min(fatigue, 1.0);\n  }\n  distance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n  }\n  async start() {\n    try {\n      if (this.isRunning) {\n        console.log('Sistema já está em execução');\n        return;\n      }\n      console.log('Iniciando sistema de detecção facial...');\n\n      // Verificar disponibilidade de câmera\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      if (videoDevices.length === 0) {\n        throw new Error('NotFoundError');\n      }\n\n      // Não precisamos obter a stream duas vezes - vamos apenas verificar permissões\n      // A stream será obtida no loop abaixo\n      console.log('Verificando disponibilidade da câmera...');\n\n      // Inicializar MediaPipe\n      await this.initialize();\n      if (!this.faceMesh) {\n        throw new Error('MediaPipe não inicializou corretamente');\n      }\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        throw new Error('Elemento de vídeo não encontrado');\n      }\n\n      // Configurar elemento de vídeo\n      Object.assign(videoElement.style, {\n        display: 'block',\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '1px',\n        height: '1px',\n        opacity: '0.01'\n      });\n      videoElement.muted = true;\n      videoElement.playsInline = true;\n      videoElement.crossOrigin = 'anonymous';\n      if (!window.Camera) {\n        throw new Error('MediaPipe Camera API não disponível');\n      }\n      console.log('Iniciando câmera com MediaPipe...');\n\n      // Criar e configurar câmera com retry e timeout\n      const maxRetries = 3;\n      let cameraStarted = false;\n      for (let i = 0; i < maxRetries && !cameraStarted; i++) {\n        try {\n          // Obter um stream de vídeo diretamente\n          const stream = await navigator.mediaDevices.getUserMedia({\n            video: {\n              width: {\n                ideal: 640\n              },\n              height: {\n                ideal: 480\n              },\n              facingMode: \"user\",\n              frameRate: {\n                ideal: 30\n              }\n            },\n            audio: false\n          });\n\n          // Armazenar a stream antes de atribuir\n          this.stream = stream;\n\n          // Parar qualquer stream anterior se existir\n          if (videoElement.srcObject) {\n            const oldTracks = videoElement.srcObject.getVideoTracks();\n            oldTracks.forEach(track => track.stop());\n          }\n\n          // Atribuir o stream ao elemento de vídeo\n          videoElement.srcObject = stream;\n\n          // Aguardar o vídeo estar pronto antes de tentar play\n          await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n              reject(new Error('Timeout ao aguardar vídeo carregar'));\n            }, 5000);\n            const onCanPlay = () => {\n              clearTimeout(timeout);\n              videoElement.removeEventListener('canplay', onCanPlay);\n              resolve();\n            };\n            videoElement.addEventListener('canplay', onCanPlay, {\n              once: true\n            });\n            videoElement.addEventListener('error', e => {\n              var _videoElement$error;\n              clearTimeout(timeout);\n              reject(new Error(`Erro ao carregar vídeo: ${((_videoElement$error = videoElement.error) === null || _videoElement$error === void 0 ? void 0 : _videoElement$error.message) || 'Erro desconhecido'}`));\n            }, {\n              once: true\n            });\n            videoElement.load(); // Forçar carregamento\n          });\n          await videoElement.play();\n\n          // Configurar a câmera do MediaPipe\n          this.camera = new window.Camera(videoElement, {\n            onFrame: async () => {\n              if (this.faceMesh && videoElement.readyState === 4) {\n                try {\n                  await this.faceMesh.send({\n                    image: videoElement\n                  });\n                } catch (error) {\n                  if (!error.message.includes('Canvas has been cleared')) {\n                    console.warn('Erro no processamento do frame:', error);\n                  }\n                }\n              }\n            },\n            width: 640,\n            height: 480\n          });\n\n          // Iniciar o processamento da câmera com retry em caso de falha\n          let startAttempts = 0;\n          const maxStartAttempts = 3;\n          while (startAttempts < maxStartAttempts) {\n            try {\n              await Promise.race([this.camera.start(), new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout ao iniciar câmera')), 5000))]);\n              cameraStarted = true;\n              console.log('Câmera iniciada com sucesso');\n              break;\n            } catch (startError) {\n              startAttempts++;\n              console.warn(`Tentativa ${startAttempts} de iniciar câmera falhou:`, startError);\n              if (startAttempts === maxStartAttempts) throw startError;\n              await new Promise(resolve => setTimeout(resolve, 1000));\n            }\n          }\n        } catch (error) {\n          console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n\n          // Limpar recursos em caso de erro\n          if (this.camera) {\n            try {\n              this.camera.stop();\n              this.camera = null;\n            } catch (e) {\n              console.warn('Erro ao parar câmera:', e);\n            }\n          }\n\n          // Limpar stream em caso de erro\n          if (videoElement.srcObject) {\n            const tracks = videoElement.srcObject.getVideoTracks();\n            tracks.forEach(track => track.stop());\n            videoElement.srcObject = null;\n            this.stream = null;\n          }\n          if (i === maxRetries - 1) {\n            this.isRunning = false;\n            throw error;\n          }\n          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n      }\n\n      // Verificar se o vídeo está recebendo frames\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Timeout aguardando frames de vídeo'));\n        }, 10000); // Aumentar timeout para 10 segundos\n\n        const checkVideo = () => {\n          if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n            clearTimeout(timeout);\n            resolve();\n          } else {\n            requestAnimationFrame(checkVideo);\n          }\n        };\n\n        // Verificar imediatamente e também aguardar eventos\n        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n          clearTimeout(timeout);\n          resolve();\n        } else {\n          videoElement.addEventListener('playing', checkVideo, {\n            once: true\n          });\n          videoElement.addEventListener('loadedmetadata', checkVideo, {\n            once: true\n          });\n          videoElement.addEventListener('error', e => {\n            var _videoElement$error2;\n            clearTimeout(timeout);\n            reject(new Error(`Erro no elemento de vídeo: ${((_videoElement$error2 = videoElement.error) === null || _videoElement$error2 === void 0 ? void 0 : _videoElement$error2.message) || 'Erro desconhecido'}`));\n          }, {\n            once: true\n          });\n        }\n      });\n\n      // IMPORTANTE: Marcar como rodando APÓS tudo estar funcionando\n      this.isRunning = true;\n\n      // Armazenar a stream atual\n      this.stream = videoElement.srcObject;\n\n      // Iniciar health check apenas após a câmera estar funcionando\n      if (!this.healthCheckInterval) {\n        this.startHealthCheck();\n      }\n      if (this.onReady) {\n        this.onReady();\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n\n      // Informar o usuário sobre o problema específico\n      let userMessage = 'Erro ao iniciar o sistema de monitoramento: ';\n      if (error.name === 'NotAllowedError' || error.message.includes('Permission denied')) {\n        userMessage += 'Permissão da câmera negada. Por favor, permita o acesso à câmera e recarregue a página.';\n      } else if (error.name === 'NotFoundError' || error.message.includes('Requested device not found')) {\n        userMessage += 'Nenhuma câmera encontrada. Conecte uma câmera e recarregue a página.';\n      } else if (error.name === 'NotReadableError' || error.message.includes('Could not start video source')) {\n        userMessage += 'Câmera pode estar em uso por outro aplicativo. Feche outros programas que possam estar usando a câmera.';\n      } else if (error.name === 'NotSupportedError') {\n        userMessage += 'Sua câmera não é compatível com os requisitos necessários. Tente usar outra câmera.';\n      } else if (error.message.includes('Timeout')) {\n        userMessage += 'Tempo excedido ao tentar acessar a câmera. Tente recarregar a página.';\n      } else {\n        userMessage += error.message || 'Erro desconhecido ao acessar a câmera.';\n      }\n      console.warn(userMessage);\n\n      // Limpar recursos em caso de erro\n      this.isRunning = false;\n      this.isReconnecting = false;\n      if (this.stream) {\n        const tracks = this.stream.getVideoTracks();\n        tracks.forEach(track => track.stop());\n        this.stream = null;\n      }\n\n      // Limpar elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement && videoElement.srcObject) {\n        const tracks = videoElement.srcObject.getVideoTracks();\n        tracks.forEach(track => track.stop());\n        videoElement.srcObject = null;\n      }\n      throw error; // Vamos deixar o StudentView lidar com o erro\n    }\n  }\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? 1.0 - fatigueScore * 0.5 : 0.0\n      });\n    }, 2000);\n  }\n  async stop() {\n    try {\n      // Parar health check\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n        this.healthCheckInterval = null;\n      }\n\n      // Parar câmera do MediaPipe\n      if (this.camera) {\n        try {\n          await this.camera.stop();\n        } catch (error) {\n          console.warn('Erro ao parar câmera MediaPipe:', error);\n        }\n        this.camera = null;\n      }\n\n      // Fechar FaceMesh\n      if (this.faceMesh) {\n        try {\n          await this.faceMesh.close();\n        } catch (error) {\n          console.warn('Erro ao fechar FaceMesh:', error);\n        }\n        this.faceMesh = null;\n      }\n      this.isInitialized = false;\n      this.isRunning = false;\n      this.isReconnecting = false;\n\n      // Parar todas as tracks do stream\n      if (this.stream) {\n        const tracks = this.stream.getVideoTracks();\n        tracks.forEach(track => {\n          track.stop();\n        });\n        this.stream = null;\n      }\n\n      // Limpar o elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement) {\n        if (videoElement.srcObject) {\n          const tracks = videoElement.srcObject.getVideoTracks();\n          tracks.forEach(track => track.stop());\n        }\n        videoElement.srcObject = null;\n        videoElement.load();\n      }\n      console.log('Sistema de detecção facial parado com sucesso');\n    } catch (error) {\n      console.error('Erro ao parar o sistema:', error);\n      this.isRunning = false;\n    }\n  }\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}","map":{"version":3,"names":["FaceDetectionSystem","constructor","onDetectionUpdate","onReady","lastBlinkTime","earHistory","blinkCount","yawnCount","lastYawnTime","eyeOpenTime","stressScore","gazeOffScreen","faceMesh","camera","isInitialized","stream","isRunning","healthCheckInterval","isReconnecting","startHealthCheck","setInterval","videoElement","document","getElementById","srcObject","console","warn","tracks","getVideoTracks","length","readyState","wasRunning","stop","Promise","resolve","setTimeout","start","error","log","initialize","navigator","mediaDevices","getUserMedia","Error","window","FaceMesh","Camera","Module","hasOwnProperty","arguments","originalModule","Object","defineProperty","value","writable","enumerable","configurable","Proxy","get","target","prop","arguments_","set","has","getOwnPropertyDescriptor","proxyError","scripts","src","loadScript","fallbackSrc","replace","fallbackError","maxWaitAttempts","waitAttempt","MediaPipe","keys","locateFileCache","faceMeshOptions","locateFile","file","fileName","split","pop","unpkgUrl","jsdelivrUrl","url","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","faceMeshCreated","attempts","maxAttempts","errorMsg","message","toString","stack","includes","simpleOptions","simpleError","initError","close","retryError","onResults","results","processResults","reject","existingScript","Array","from","querySelectorAll","find","s","script","createElement","crossOrigin","async","onload","onerror","head","appendChild","multiFaceLandmarks","faceDetected","gazeOnScreen","fatigueScore","landmarks","eyeAspectRatio","calculateEAR","yawnRatio","calculateYawnRatio","gazeDirection","estimateGaze","currentTime","Date","now","calculateFatigue","isGazeOnScreen","x","y","Math","min","attentionScore","leftEAR","getEyeAspectRatio","rightEAR","eyePoints","verticalDist1","distance","verticalDist2","horizontalDist","mouthTop","mouthBottom","mouthOpening","abs","noseTip","leftEyeCenter","rightEyeCenter","gazeX","gazeY","EAR","fatigue","point1","point2","sqrt","pow","devices","enumerateDevices","videoDevices","filter","device","kind","assign","style","display","position","top","left","width","height","opacity","muted","playsInline","maxRetries","cameraStarted","i","video","ideal","facingMode","frameRate","audio","oldTracks","forEach","track","timeout","onCanPlay","clearTimeout","removeEventListener","addEventListener","once","e","_videoElement$error","load","play","onFrame","send","image","startAttempts","maxStartAttempts","race","_","startError","checkVideo","videoWidth","videoHeight","requestAnimationFrame","_videoElement$error2","userMessage","name","simulateDetection","simulationInterval","random","blinkIncrement","floor","clearInterval","resetCounters"],"sources":["/Users/macbookair/Documents/GitHub/Sistema-de-Monitoramento-de-Engajamento-em-Aulas-Online/frontend/src/utils/FaceDetection.js"],"sourcesContent":["// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n    this.stream = null;\n    this.isRunning = false;\n    this.healthCheckInterval = null;\n    this.isReconnecting = false; // Flag para prevenir reconexões múltiplas\n    \n    // NOTA: Não iniciar health check aqui - será iniciado após a câmera estar rodando\n  }\n\n  startHealthCheck() {\n    this.healthCheckInterval = setInterval(async () => {\n      // Não fazer nada se já estiver reconectando ou não estiver rodando\n      if (this.isReconnecting || !this.isRunning) {\n        return;\n      }\n      \n      const videoElement = document.getElementById('input_video');\n      \n      // Verificar se o elemento existe e tem stream\n      if (!videoElement || !videoElement.srcObject) {\n        console.warn('Stream de vídeo não encontrado');\n        return;\n      }\n\n      // Verificar estado do vídeo de forma mais tolerante\n      const tracks = videoElement.srcObject.getVideoTracks();\n      if (tracks.length === 0 || tracks[0].readyState === 'ended') {\n        console.warn('Track de vídeo foi finalizada, tentando reconectar...');\n        \n        // Prevenir múltiplas reconexões simultâneas\n        if (this.isReconnecting) {\n          return;\n        }\n        \n        this.isReconnecting = true;\n        try {\n          // Parar tudo antes de reconectar\n          const wasRunning = this.isRunning;\n          await this.stop();\n          \n          // Aguardar um pouco antes de reconectar\n          await new Promise(resolve => setTimeout(resolve, 2000));\n          \n          // Se estava rodando antes, reconectar\n          if (wasRunning) {\n            await this.start();\n          }\n        } catch (error) {\n          console.error('Falha ao reconectar câmera:', error);\n          this.isRunning = false;\n        } finally {\n          this.isReconnecting = false;\n        }\n      } else if (videoElement.readyState < 2) {\n        // readyState < 2 significa que o vídeo ainda está carregando\n        // Isso é normal, não precisa reconectar\n        console.log('Vídeo ainda carregando, readyState:', videoElement.readyState);\n      }\n    }, 10000); // Verificar a cada 10 segundos (menos agressivo)\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      console.log('Iniciando carregamento do MediaPipe...');\n      \n      // Verificar suporte do navegador\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Este navegador não suporta acesso à câmera');\n      }\n\n      // Carregar MediaPipe dinamicamente se ainda não estiver carregado\n      if (typeof window === 'undefined' || !window.FaceMesh || !window.Camera) {\n        console.log('Carregando MediaPipe dinamicamente...');\n        \n        // Configurar Module ANTES de carregar para evitar erro Module.arguments\n        if (typeof window !== 'undefined') {\n          // Criar ou obter Module global\n          if (!window.Module) {\n            window.Module = {};\n          }\n          \n          // Remover arguments se existir\n          if (window.Module.hasOwnProperty('arguments')) {\n            delete window.Module.arguments;\n          }\n          \n          // Interceptar acesso a Module.arguments usando Proxy\n          // Isso permite que o código WASM acesse Module.arguments sem erro\n          try {\n            const originalModule = window.Module;\n            \n            // Primeiro, definir arguments_ como propriedade não-enumerável\n            Object.defineProperty(originalModule, 'arguments_', {\n              value: [],\n              writable: true,\n              enumerable: false,\n              configurable: true\n            });\n            \n            // Criar Proxy para interceptar acessos\n            window.Module = new Proxy(originalModule, {\n              get: function(target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar arguments_ em vez de arguments\n                  return target.arguments_ || [];\n                }\n                return target[prop];\n              },\n              set: function(target, prop, value) {\n                if (prop === 'arguments') {\n                  // Redirecionar para arguments_\n                  if (!target.arguments_) {\n                    target.arguments_ = [];\n                  }\n                  // Não definir arguments diretamente\n                  console.warn('Tentativa de definir Module.arguments redirecionada para arguments_');\n                  return true;\n                }\n                target[prop] = value;\n                return true;\n              },\n              has: function(target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar true mas redirecionar para arguments_\n                  return true;\n                }\n                return prop in target;\n              },\n              getOwnPropertyDescriptor: function(target, prop) {\n                if (prop === 'arguments') {\n                  // Retornar descriptor para arguments_ em vez de arguments\n                  return Object.getOwnPropertyDescriptor(target, 'arguments_') || {\n                    value: target.arguments_ || [],\n                    writable: true,\n                    enumerable: false,\n                    configurable: true\n                  };\n                }\n                return Object.getOwnPropertyDescriptor(target, prop);\n              }\n            });\n            console.log('Module configurado com Proxy para evitar erro arguments');\n          } catch (proxyError) {\n            console.warn('Não foi possível criar Proxy para Module:', proxyError);\n            // Continuar mesmo sem Proxy, mas pelo menos garantir arguments_\n            if (window.Module && !window.Module.arguments_) {\n              window.Module.arguments_ = [];\n            }\n          }\n        }\n        \n        // Carregar scripts do MediaPipe\n        const scripts = [\n          'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js',\n          'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js'\n        ];\n        \n        // Tentar carregar scripts um por um\n        for (const src of scripts) {\n          try {\n            await this.loadScript(src);\n            // Aguardar um pouco entre carregamentos\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            // Após carregar cada script, verificar e corrigir Module novamente\n            if (typeof window !== 'undefined' && window.Module) {\n              // Remover arguments se foi adicionado pelo script\n              if (window.Module.hasOwnProperty('arguments')) {\n                delete window.Module.arguments;\n              }\n              \n              // Garantir que arguments_ existe (o novo nome esperado)\n              if (!window.Module.hasOwnProperty('arguments_')) {\n                window.Module.arguments_ = [];\n              }\n            }\n          } catch (error) {\n            console.warn(`Falha ao carregar ${src}, tentando alternativa...`);\n            // Tentar sem versão específica\n            const fallbackSrc = src.replace(/@[\\d.]+/g, '');\n            try {\n              await this.loadScript(fallbackSrc);\n              await new Promise(resolve => setTimeout(resolve, 500));\n              \n              // Corrigir Module após fallback também\n              if (typeof window !== 'undefined' && window.Module) {\n                if (window.Module.hasOwnProperty('arguments')) {\n                  delete window.Module.arguments;\n                }\n                if (!window.Module.hasOwnProperty('arguments_')) {\n                  window.Module.arguments_ = [];\n                }\n              }\n            } catch (fallbackError) {\n              console.error(`Falha ao carregar alternativa: ${fallbackSrc}`);\n              throw new Error(`Não foi possível carregar MediaPipe: ${src}`);\n            }\n          }\n        }\n        \n        // Aguardar até que o MediaPipe esteja disponível\n        let maxWaitAttempts = 30; // 3 segundos máximo (30 * 100ms)\n        let waitAttempt = 0;\n        \n        while (typeof window === 'undefined' || !window.FaceMesh || !window.Camera) {\n          if (waitAttempt >= maxWaitAttempts) {\n            throw new Error('MediaPipe não foi carregado após tentativas.');\n          }\n          await new Promise(resolve => setTimeout(resolve, 100));\n          waitAttempt++;\n        }\n        \n        // Última verificação e correção do Module após MediaPipe estar disponível\n        if (typeof window !== 'undefined' && window.Module) {\n          // Remover arguments se ainda existir\n          if (window.Module.hasOwnProperty('arguments')) {\n            delete window.Module.arguments;\n            console.log('Module.arguments removido após carregamento do MediaPipe');\n          }\n          \n          // Garantir que arguments_ existe\n          if (!window.Module.hasOwnProperty('arguments_')) {\n            window.Module.arguments_ = [];\n            console.log('Module.arguments_ criado');\n          }\n        }\n      }\n      \n      console.log('MediaPipe está disponível');\n      \n      // Verificar se FaceMesh e Camera são realmente funções\n      if (typeof window.FaceMesh !== 'function') {\n        console.error('window.FaceMesh:', typeof window.FaceMesh, window.FaceMesh);\n        throw new Error('FaceMesh não é uma função. MediaPipe pode não estar carregado corretamente.');\n      }\n      if (typeof window.Camera !== 'function') {\n        console.error('window.Camera:', typeof window.Camera, window.Camera);\n        throw new Error('Camera não é uma função. MediaPipe pode não estar carregado corretamente.');\n      }\n      \n      // Verificar se há um objeto MediaPipe global e suas propriedades\n      if (window.MediaPipe) {\n        console.log('MediaPipe global encontrado:', Object.keys(window.MediaPipe));\n      }\n      \n      // Aguardar mais tempo para garantir que todos os módulos estão prontos\n      console.log('Aguardando MediaPipe estar completamente pronto...');\n      await new Promise(resolve => setTimeout(resolve, 1500));\n\n      // Verificação final e correção do Module antes de criar FaceMesh\n      if (typeof window !== 'undefined' && window.Module) {\n        // Garantir que não há arguments\n        if (window.Module.hasOwnProperty('arguments')) {\n          delete window.Module.arguments;\n          console.log('Module.arguments removido antes de criar FaceMesh');\n        }\n        \n        // Garantir que arguments_ existe\n        if (!window.Module.hasOwnProperty('arguments_')) {\n          Object.defineProperty(window.Module, 'arguments_', {\n            value: [],\n            writable: true,\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n\n      console.log('Configurando FaceMesh...');\n      \n      // Configurar FaceMesh com locateFile correto para CDN\n      // O MediaPipe precisa saber onde encontrar os arquivos WASM e outros recursos\n      // Vamos usar um objeto para rastrear tentativas e ter fallback\n      const locateFileCache = {};\n      \n      const faceMeshOptions = {\n        locateFile: (file) => {\n          console.log('FaceMesh solicitando arquivo:', file);\n          \n          // Se já tentamos este arquivo, retornar o cache\n          if (locateFileCache[file]) {\n            return locateFileCache[file];\n          }\n          \n          const fileName = file.split('/').pop();\n          \n          // Tentar unpkg primeiro (melhor para arquivos estáticos)\n          const unpkgUrl = `https://unpkg.com/@mediapipe/face_mesh@0.4.1633559619/${fileName}`;\n          \n          // Fallback para jsdelivr se necessário\n          const jsdelivrUrl = `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${fileName}`;\n          \n          // Usar unpkg como padrão (mais confiável para arquivos binários)\n          const url = unpkgUrl;\n          \n          locateFileCache[file] = url;\n          console.log('Retornando URL do CDN:', url);\n          return url;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n      \n      let faceMeshCreated = false;\n      let attempts = 0;\n      const maxAttempts = 3;\n      \n      while (!faceMeshCreated && attempts < maxAttempts) {\n        try {\n          attempts++;\n          console.log(`Tentativa ${attempts} de criar FaceMesh...`);\n          \n          // Verificar novamente se FaceMesh está disponível antes de tentar criar\n          if (typeof window.FaceMesh !== 'function') {\n            throw new Error('FaceMesh não está disponível como função');\n          }\n          \n          this.faceMesh = new window.FaceMesh(faceMeshOptions);\n          \n          // Verificar se a instância foi criada corretamente\n          if (!this.faceMesh) {\n            throw new Error('FaceMesh não foi criado - instância é null ou undefined');\n          }\n          \n          // Verificar se o método initialize existe e é uma função\n          if (typeof this.faceMesh.initialize !== 'function') {\n            console.error('FaceMesh métodos disponíveis:', Object.keys(this.faceMesh));\n            throw new Error(`FaceMesh.initialize não é uma função (tipo: ${typeof this.faceMesh.initialize})`);\n          }\n          \n          faceMeshCreated = true;\n          console.log('FaceMesh criado com sucesso');\n        } catch (error) {\n          const errorMsg = error.message || error.toString();\n          console.warn(`Erro ao criar FaceMesh (tentativa ${attempts}):`, errorMsg);\n          console.error('Stack trace:', error.stack);\n          \n          // Se for o erro \"z is not a function\", tentar abordagem diferente\n          if (errorMsg.includes('z is not a function') || errorMsg.includes('is not a function')) {\n            console.warn('Erro de função não encontrada detectado. Tentando abordagem alternativa...');\n            \n            // Tentar criar sem locateFile personalizado\n            try {\n              await new Promise(resolve => setTimeout(resolve, 1000));\n              \n              const simpleOptions = {\n                maxNumFaces: 1,\n                refineLandmarks: true,\n                minDetectionConfidence: 0.5,\n                minTrackingConfidence: 0.5\n              };\n              \n              this.faceMesh = new window.FaceMesh(simpleOptions);\n              \n              if (this.faceMesh && typeof this.faceMesh.initialize === 'function') {\n                faceMeshCreated = true;\n                console.log('FaceMesh criado com opções simples');\n                break;\n              }\n            } catch (simpleError) {\n              console.warn('Tentativa com opções simples também falhou:', simpleError);\n            }\n          }\n          \n          if (attempts >= maxAttempts && !faceMeshCreated) {\n            throw new Error(`Não foi possível criar FaceMesh após ${maxAttempts} tentativas: ${errorMsg}`);\n          }\n          \n          // Aguardar antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 1000 * attempts));\n        }\n      }\n\n      // Aguardar antes de inicializar para garantir que tudo está pronto\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      try {\n        console.log('Inicializando FaceMesh...');\n        await this.faceMesh.initialize();\n        console.log('FaceMesh inicializado com sucesso');\n      } catch (initError) {\n        console.error('Erro ao inicializar FaceMesh:', initError);\n        \n        // Tentar limpar e reinicializar uma vez\n        try {\n          if (this.faceMesh && typeof this.faceMesh.close === 'function') {\n            await this.faceMesh.close();\n          }\n          \n          // Aguardar antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 1500));\n          \n          // Tentar criar uma nova instância\n          this.faceMesh = new window.FaceMesh(faceMeshOptions);\n          await new Promise(resolve => setTimeout(resolve, 500));\n          await this.faceMesh.initialize();\n          console.log('FaceMesh reinicializado com sucesso');\n        } catch (retryError) {\n          console.error('Falha ao reinicializar FaceMesh:', retryError);\n          throw new Error(`Erro ao inicializar FaceMesh: ${initError.message}. Tentativa de recuperação falhou: ${retryError.message}`);\n        }\n      }\n\n      this.faceMesh.onResults((results) => {\n        this.processResults(results);\n      });\n\n      console.log('FaceMesh configurado com sucesso');\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Erro na inicialização:', error);\n      throw error;\n    }\n  }\n\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      // Verificar se o script já foi carregado\n      const existingScript = Array.from(document.querySelectorAll('script')).find(\n        s => s.src === src || s.src.includes(src.split('/').pop())\n      );\n      \n      if (existingScript && (window.FaceMesh || window.Camera)) {\n        console.log('Script já carregado:', src);\n        resolve();\n        return;\n      }\n      \n      const script = document.createElement('script');\n      script.src = src;\n      script.crossOrigin = 'anonymous';\n      script.async = true;\n      \n      // Verificar se o conteúdo carregado é JavaScript válido\n      script.onload = () => {\n        // Verificar se não é uma página de erro HTML\n        if (window.FaceMesh || window.Camera || src.includes('face_mesh') || src.includes('camera_utils')) {\n          console.log('Script carregado com sucesso:', src);\n          resolve();\n        } else {\n          // Aguardar um pouco mais antes de considerar erro\n          setTimeout(() => {\n            if (window.FaceMesh || window.Camera) {\n              resolve();\n            } else {\n              reject(new Error(`Script ${src} não carregou corretamente (possível erro HTML)`));\n            }\n          }, 1000);\n        }\n      };\n      \n      script.onerror = (error) => {\n        console.error('Erro ao carregar script:', src, error);\n        reject(new Error(`Falha ao carregar ${src}. Verifique se a URL está correta e acessível.`));\n      };\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && \n                           gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    \n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n\n  calculateEAR(landmarks) {\n    try {\n      const leftEAR = this.getEyeAspectRatio([\n        landmarks[33], landmarks[133], landmarks[157], \n        landmarks[158], landmarks[159], landmarks[160]\n      ]);\n      \n      const rightEAR = this.getEyeAspectRatio([\n        landmarks[362], landmarks[385], landmarks[386],\n        landmarks[387], landmarks[388], landmarks[466]\n      ]);\n\n      return (leftEAR + rightEAR) / 2;\n    } catch (error) {\n      console.warn('Erro ao calcular EAR:', error);\n      return 0.3; // valor padrão seguro\n    }\n  }\n\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    \n    return mouthOpening;\n  }\n\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n\n    return { x: gazeX, y: gazeY };\n  }\n\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;\n    else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;\n    else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n\n    return Math.min(fatigue, 1.0);\n  }\n\n  distance(point1, point2) {\n    return Math.sqrt(\n      Math.pow(point1.x - point2.x, 2) + \n      Math.pow(point1.y - point2.y, 2)\n    );\n  }\n\n  async start() {\n    try {\n      if (this.isRunning) {\n        console.log('Sistema já está em execução');\n        return;\n      }\n\n      console.log('Iniciando sistema de detecção facial...');\n      \n      // Verificar disponibilidade de câmera\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      \n      if (videoDevices.length === 0) {\n        throw new Error('NotFoundError');\n      }\n      \n      // Não precisamos obter a stream duas vezes - vamos apenas verificar permissões\n      // A stream será obtida no loop abaixo\n      console.log('Verificando disponibilidade da câmera...');\n\n      // Inicializar MediaPipe\n      await this.initialize();\n\n      if (!this.faceMesh) {\n        throw new Error('MediaPipe não inicializou corretamente');\n      }\n\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        throw new Error('Elemento de vídeo não encontrado');\n      }\n\n      // Configurar elemento de vídeo\n      Object.assign(videoElement.style, {\n        display: 'block',\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '1px',\n        height: '1px',\n        opacity: '0.01'\n      });\n      \n      videoElement.muted = true;\n      videoElement.playsInline = true;\n      videoElement.crossOrigin = 'anonymous';\n\n      if (!window.Camera) {\n        throw new Error('MediaPipe Camera API não disponível');\n      }\n\n      console.log('Iniciando câmera com MediaPipe...');\n      \n      // Criar e configurar câmera com retry e timeout\n      const maxRetries = 3;\n      let cameraStarted = false;\n      \n      for (let i = 0; i < maxRetries && !cameraStarted; i++) {\n        try {\n          // Obter um stream de vídeo diretamente\n          const stream = await navigator.mediaDevices.getUserMedia({\n            video: {\n              width: { ideal: 640 },\n              height: { ideal: 480 },\n              facingMode: \"user\",\n              frameRate: { ideal: 30 }\n            },\n            audio: false\n          });\n\n          // Armazenar a stream antes de atribuir\n          this.stream = stream;\n\n          // Parar qualquer stream anterior se existir\n          if (videoElement.srcObject) {\n            const oldTracks = videoElement.srcObject.getVideoTracks();\n            oldTracks.forEach(track => track.stop());\n          }\n\n          // Atribuir o stream ao elemento de vídeo\n          videoElement.srcObject = stream;\n          \n          // Aguardar o vídeo estar pronto antes de tentar play\n          await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n              reject(new Error('Timeout ao aguardar vídeo carregar'));\n            }, 5000);\n            \n            const onCanPlay = () => {\n              clearTimeout(timeout);\n              videoElement.removeEventListener('canplay', onCanPlay);\n              resolve();\n            };\n            \n            videoElement.addEventListener('canplay', onCanPlay, { once: true });\n            videoElement.addEventListener('error', (e) => {\n              clearTimeout(timeout);\n              reject(new Error(`Erro ao carregar vídeo: ${videoElement.error?.message || 'Erro desconhecido'}`));\n            }, { once: true });\n            \n            videoElement.load(); // Forçar carregamento\n          });\n          \n          await videoElement.play();\n\n          // Configurar a câmera do MediaPipe\n          this.camera = new window.Camera(videoElement, {\n            onFrame: async () => {\n              if (this.faceMesh && videoElement.readyState === 4) {\n                try {\n                  await this.faceMesh.send({ image: videoElement });\n                } catch (error) {\n                  if (!error.message.includes('Canvas has been cleared')) {\n                    console.warn('Erro no processamento do frame:', error);\n                  }\n                }\n              }\n            },\n            width: 640,\n            height: 480\n          });\n\n          // Iniciar o processamento da câmera com retry em caso de falha\n          let startAttempts = 0;\n          const maxStartAttempts = 3;\n          \n          while (startAttempts < maxStartAttempts) {\n            try {\n              await Promise.race([\n                this.camera.start(),\n                new Promise((_, reject) => \n                  setTimeout(() => reject(new Error('Timeout ao iniciar câmera')), 5000)\n                )\n              ]);\n              cameraStarted = true;\n              console.log('Câmera iniciada com sucesso');\n              break;\n            } catch (startError) {\n              startAttempts++;\n              console.warn(`Tentativa ${startAttempts} de iniciar câmera falhou:`, startError);\n              if (startAttempts === maxStartAttempts) throw startError;\n              await new Promise(resolve => setTimeout(resolve, 1000));\n            }\n          }\n        } catch (error) {\n          console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n          \n          // Limpar recursos em caso de erro\n          if (this.camera) {\n            try {\n              this.camera.stop();\n              this.camera = null;\n            } catch (e) {\n              console.warn('Erro ao parar câmera:', e);\n            }\n          }\n          \n          // Limpar stream em caso de erro\n          if (videoElement.srcObject) {\n            const tracks = videoElement.srcObject.getVideoTracks();\n            tracks.forEach(track => track.stop());\n            videoElement.srcObject = null;\n            this.stream = null;\n          }\n          \n          if (i === maxRetries - 1) {\n            this.isRunning = false;\n            throw error;\n          }\n          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n      }\n\n      // Verificar se o vídeo está recebendo frames\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Timeout aguardando frames de vídeo'));\n        }, 10000); // Aumentar timeout para 10 segundos\n\n        const checkVideo = () => {\n          if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n            clearTimeout(timeout);\n            resolve();\n          } else {\n            requestAnimationFrame(checkVideo);\n          }\n        };\n\n        // Verificar imediatamente e também aguardar eventos\n        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n          clearTimeout(timeout);\n          resolve();\n        } else {\n          videoElement.addEventListener('playing', checkVideo, { once: true });\n          videoElement.addEventListener('loadedmetadata', checkVideo, { once: true });\n          videoElement.addEventListener('error', (e) => {\n            clearTimeout(timeout);\n            reject(new Error(`Erro no elemento de vídeo: ${videoElement.error?.message || 'Erro desconhecido'}`));\n          }, { once: true });\n        }\n      });\n\n      // IMPORTANTE: Marcar como rodando APÓS tudo estar funcionando\n      this.isRunning = true;\n      \n      // Armazenar a stream atual\n      this.stream = videoElement.srcObject;\n      \n      // Iniciar health check apenas após a câmera estar funcionando\n      if (!this.healthCheckInterval) {\n        this.startHealthCheck();\n      }\n\n      if (this.onReady) {\n        this.onReady();\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n      \n      // Informar o usuário sobre o problema específico\n      let userMessage = 'Erro ao iniciar o sistema de monitoramento: ';\n      if (error.name === 'NotAllowedError' || error.message.includes('Permission denied')) {\n        userMessage += 'Permissão da câmera negada. Por favor, permita o acesso à câmera e recarregue a página.';\n      } else if (error.name === 'NotFoundError' || error.message.includes('Requested device not found')) {\n        userMessage += 'Nenhuma câmera encontrada. Conecte uma câmera e recarregue a página.';\n      } else if (error.name === 'NotReadableError' || error.message.includes('Could not start video source')) {\n        userMessage += 'Câmera pode estar em uso por outro aplicativo. Feche outros programas que possam estar usando a câmera.';\n      } else if (error.name === 'NotSupportedError') {\n        userMessage += 'Sua câmera não é compatível com os requisitos necessários. Tente usar outra câmera.';\n      } else if (error.message.includes('Timeout')) {\n        userMessage += 'Tempo excedido ao tentar acessar a câmera. Tente recarregar a página.';\n      } else {\n        userMessage += error.message || 'Erro desconhecido ao acessar a câmera.';\n      }\n      \n      console.warn(userMessage);\n      \n      // Limpar recursos em caso de erro\n      this.isRunning = false;\n      this.isReconnecting = false;\n      if (this.stream) {\n        const tracks = this.stream.getVideoTracks();\n        tracks.forEach(track => track.stop());\n        this.stream = null;\n      }\n      \n      // Limpar elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement && videoElement.srcObject) {\n        const tracks = videoElement.srcObject.getVideoTracks();\n        tracks.forEach(track => track.stop());\n        videoElement.srcObject = null;\n      }\n      \n      throw error;  // Vamos deixar o StudentView lidar com o erro\n    }\n  }\n\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? (1.0 - fatigueScore * 0.5) : 0.0\n      });\n    }, 2000);\n  }\n\n  async stop() {\n    try {\n      // Parar health check\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n        this.healthCheckInterval = null;\n      }\n      \n      // Parar câmera do MediaPipe\n      if (this.camera) {\n        try {\n          await this.camera.stop();\n        } catch (error) {\n          console.warn('Erro ao parar câmera MediaPipe:', error);\n        }\n        this.camera = null;\n      }\n      \n      // Fechar FaceMesh\n      if (this.faceMesh) {\n        try {\n          await this.faceMesh.close();\n        } catch (error) {\n          console.warn('Erro ao fechar FaceMesh:', error);\n        }\n        this.faceMesh = null;\n      }\n      \n      this.isInitialized = false;\n      this.isRunning = false;\n      this.isReconnecting = false;\n      \n      // Parar todas as tracks do stream\n      if (this.stream) {\n        const tracks = this.stream.getVideoTracks();\n        tracks.forEach(track => {\n          track.stop();\n        });\n        this.stream = null;\n      }\n      \n      // Limpar o elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement) {\n        if (videoElement.srcObject) {\n          const tracks = videoElement.srcObject.getVideoTracks();\n          tracks.forEach(track => track.stop());\n        }\n        videoElement.srcObject = null;\n        videoElement.load();\n      }\n      \n      console.log('Sistema de detecção facial parado com sucesso');\n    } catch (error) {\n      console.error('Erro ao parar o sistema:', error);\n      this.isRunning = false;\n    }\n  }\n\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}\n\n"],"mappings":"AAAA;;AAEA,OAAO,MAAMA,mBAAmB,CAAC;EAC/BC,WAAWA,CAACC,iBAAiB,EAAEC,OAAO,EAAE;IACtC,IAAI,CAACD,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,OAAO,GAAGA,OAAO;IAEtB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,aAAa,GAAG,CAAC;IAEtB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,cAAc,GAAG,KAAK,CAAC,CAAC;;IAE7B;EACF;EAEAC,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAACF,mBAAmB,GAAGG,WAAW,CAAC,YAAY;MACjD;MACA,IAAI,IAAI,CAACF,cAAc,IAAI,CAAC,IAAI,CAACF,SAAS,EAAE;QAC1C;MACF;MAEA,MAAMK,YAAY,GAAGC,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;;MAE3D;MACA,IAAI,CAACF,YAAY,IAAI,CAACA,YAAY,CAACG,SAAS,EAAE;QAC5CC,OAAO,CAACC,IAAI,CAAC,gCAAgC,CAAC;QAC9C;MACF;;MAEA;MACA,MAAMC,MAAM,GAAGN,YAAY,CAACG,SAAS,CAACI,cAAc,CAAC,CAAC;MACtD,IAAID,MAAM,CAACE,MAAM,KAAK,CAAC,IAAIF,MAAM,CAAC,CAAC,CAAC,CAACG,UAAU,KAAK,OAAO,EAAE;QAC3DL,OAAO,CAACC,IAAI,CAAC,uDAAuD,CAAC;;QAErE;QACA,IAAI,IAAI,CAACR,cAAc,EAAE;UACvB;QACF;QAEA,IAAI,CAACA,cAAc,GAAG,IAAI;QAC1B,IAAI;UACF;UACA,MAAMa,UAAU,GAAG,IAAI,CAACf,SAAS;UACjC,MAAM,IAAI,CAACgB,IAAI,CAAC,CAAC;;UAEjB;UACA,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;UAEvD;UACA,IAAIH,UAAU,EAAE;YACd,MAAM,IAAI,CAACK,KAAK,CAAC,CAAC;UACpB;QACF,CAAC,CAAC,OAAOC,KAAK,EAAE;UACdZ,OAAO,CAACY,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;UACnD,IAAI,CAACrB,SAAS,GAAG,KAAK;QACxB,CAAC,SAAS;UACR,IAAI,CAACE,cAAc,GAAG,KAAK;QAC7B;MACF,CAAC,MAAM,IAAIG,YAAY,CAACS,UAAU,GAAG,CAAC,EAAE;QACtC;QACA;QACAL,OAAO,CAACa,GAAG,CAAC,qCAAqC,EAAEjB,YAAY,CAACS,UAAU,CAAC;MAC7E;IACF,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;EACb;EAEA,MAAMS,UAAUA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACzB,aAAa,EAAE;IAExB,IAAI;MACFW,OAAO,CAACa,GAAG,CAAC,wCAAwC,CAAC;;MAErD;MACA,IAAI,CAACE,SAAS,CAACC,YAAY,IAAI,CAACD,SAAS,CAACC,YAAY,CAACC,YAAY,EAAE;QACnE,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;MAC/D;;MAEA;MACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAI,CAACA,MAAM,CAACC,QAAQ,IAAI,CAACD,MAAM,CAACE,MAAM,EAAE;QACvErB,OAAO,CAACa,GAAG,CAAC,uCAAuC,CAAC;;QAEpD;QACA,IAAI,OAAOM,MAAM,KAAK,WAAW,EAAE;UACjC;UACA,IAAI,CAACA,MAAM,CAACG,MAAM,EAAE;YAClBH,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC;UACpB;;UAEA;UACA,IAAIH,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,WAAW,CAAC,EAAE;YAC7C,OAAOJ,MAAM,CAACG,MAAM,CAACE,SAAS;UAChC;;UAEA;UACA;UACA,IAAI;YACF,MAAMC,cAAc,GAAGN,MAAM,CAACG,MAAM;;YAEpC;YACAI,MAAM,CAACC,cAAc,CAACF,cAAc,EAAE,YAAY,EAAE;cAClDG,KAAK,EAAE,EAAE;cACTC,QAAQ,EAAE,IAAI;cACdC,UAAU,EAAE,KAAK;cACjBC,YAAY,EAAE;YAChB,CAAC,CAAC;;YAEF;YACAZ,MAAM,CAACG,MAAM,GAAG,IAAIU,KAAK,CAACP,cAAc,EAAE;cACxCQ,GAAG,EAAE,SAAAA,CAASC,MAAM,EAAEC,IAAI,EAAE;gBAC1B,IAAIA,IAAI,KAAK,WAAW,EAAE;kBACxB;kBACA,OAAOD,MAAM,CAACE,UAAU,IAAI,EAAE;gBAChC;gBACA,OAAOF,MAAM,CAACC,IAAI,CAAC;cACrB,CAAC;cACDE,GAAG,EAAE,SAAAA,CAASH,MAAM,EAAEC,IAAI,EAAEP,KAAK,EAAE;gBACjC,IAAIO,IAAI,KAAK,WAAW,EAAE;kBACxB;kBACA,IAAI,CAACD,MAAM,CAACE,UAAU,EAAE;oBACtBF,MAAM,CAACE,UAAU,GAAG,EAAE;kBACxB;kBACA;kBACApC,OAAO,CAACC,IAAI,CAAC,qEAAqE,CAAC;kBACnF,OAAO,IAAI;gBACb;gBACAiC,MAAM,CAACC,IAAI,CAAC,GAAGP,KAAK;gBACpB,OAAO,IAAI;cACb,CAAC;cACDU,GAAG,EAAE,SAAAA,CAASJ,MAAM,EAAEC,IAAI,EAAE;gBAC1B,IAAIA,IAAI,KAAK,WAAW,EAAE;kBACxB;kBACA,OAAO,IAAI;gBACb;gBACA,OAAOA,IAAI,IAAID,MAAM;cACvB,CAAC;cACDK,wBAAwB,EAAE,SAAAA,CAASL,MAAM,EAAEC,IAAI,EAAE;gBAC/C,IAAIA,IAAI,KAAK,WAAW,EAAE;kBACxB;kBACA,OAAOT,MAAM,CAACa,wBAAwB,CAACL,MAAM,EAAE,YAAY,CAAC,IAAI;oBAC9DN,KAAK,EAAEM,MAAM,CAACE,UAAU,IAAI,EAAE;oBAC9BP,QAAQ,EAAE,IAAI;oBACdC,UAAU,EAAE,KAAK;oBACjBC,YAAY,EAAE;kBAChB,CAAC;gBACH;gBACA,OAAOL,MAAM,CAACa,wBAAwB,CAACL,MAAM,EAAEC,IAAI,CAAC;cACtD;YACF,CAAC,CAAC;YACFnC,OAAO,CAACa,GAAG,CAAC,yDAAyD,CAAC;UACxE,CAAC,CAAC,OAAO2B,UAAU,EAAE;YACnBxC,OAAO,CAACC,IAAI,CAAC,2CAA2C,EAAEuC,UAAU,CAAC;YACrE;YACA,IAAIrB,MAAM,CAACG,MAAM,IAAI,CAACH,MAAM,CAACG,MAAM,CAACc,UAAU,EAAE;cAC9CjB,MAAM,CAACG,MAAM,CAACc,UAAU,GAAG,EAAE;YAC/B;UACF;QACF;;QAEA;QACA,MAAMK,OAAO,GAAG,CACd,qFAAqF,EACrF,+EAA+E,CAChF;;QAED;QACA,KAAK,MAAMC,GAAG,IAAID,OAAO,EAAE;UACzB,IAAI;YACF,MAAM,IAAI,CAACE,UAAU,CAACD,GAAG,CAAC;YAC1B;YACA,MAAM,IAAIlC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;;YAEtD;YACA,IAAI,OAAOU,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACG,MAAM,EAAE;cAClD;cACA,IAAIH,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,WAAW,CAAC,EAAE;gBAC7C,OAAOJ,MAAM,CAACG,MAAM,CAACE,SAAS;cAChC;;cAEA;cACA,IAAI,CAACL,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,YAAY,CAAC,EAAE;gBAC/CJ,MAAM,CAACG,MAAM,CAACc,UAAU,GAAG,EAAE;cAC/B;YACF;UACF,CAAC,CAAC,OAAOxB,KAAK,EAAE;YACdZ,OAAO,CAACC,IAAI,CAAC,qBAAqByC,GAAG,2BAA2B,CAAC;YACjE;YACA,MAAME,WAAW,GAAGF,GAAG,CAACG,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;YAC/C,IAAI;cACF,MAAM,IAAI,CAACF,UAAU,CAACC,WAAW,CAAC;cAClC,MAAM,IAAIpC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;;cAEtD;cACA,IAAI,OAAOU,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACG,MAAM,EAAE;gBAClD,IAAIH,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,WAAW,CAAC,EAAE;kBAC7C,OAAOJ,MAAM,CAACG,MAAM,CAACE,SAAS;gBAChC;gBACA,IAAI,CAACL,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,YAAY,CAAC,EAAE;kBAC/CJ,MAAM,CAACG,MAAM,CAACc,UAAU,GAAG,EAAE;gBAC/B;cACF;YACF,CAAC,CAAC,OAAOU,aAAa,EAAE;cACtB9C,OAAO,CAACY,KAAK,CAAC,kCAAkCgC,WAAW,EAAE,CAAC;cAC9D,MAAM,IAAI1B,KAAK,CAAC,wCAAwCwB,GAAG,EAAE,CAAC;YAChE;UACF;QACF;;QAEA;QACA,IAAIK,eAAe,GAAG,EAAE,CAAC,CAAC;QAC1B,IAAIC,WAAW,GAAG,CAAC;QAEnB,OAAO,OAAO7B,MAAM,KAAK,WAAW,IAAI,CAACA,MAAM,CAACC,QAAQ,IAAI,CAACD,MAAM,CAACE,MAAM,EAAE;UAC1E,IAAI2B,WAAW,IAAID,eAAe,EAAE;YAClC,MAAM,IAAI7B,KAAK,CAAC,8CAA8C,CAAC;UACjE;UACA,MAAM,IAAIV,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;UACtDuC,WAAW,EAAE;QACf;;QAEA;QACA,IAAI,OAAO7B,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACG,MAAM,EAAE;UAClD;UACA,IAAIH,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,WAAW,CAAC,EAAE;YAC7C,OAAOJ,MAAM,CAACG,MAAM,CAACE,SAAS;YAC9BxB,OAAO,CAACa,GAAG,CAAC,0DAA0D,CAAC;UACzE;;UAEA;UACA,IAAI,CAACM,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,YAAY,CAAC,EAAE;YAC/CJ,MAAM,CAACG,MAAM,CAACc,UAAU,GAAG,EAAE;YAC7BpC,OAAO,CAACa,GAAG,CAAC,0BAA0B,CAAC;UACzC;QACF;MACF;MAEAb,OAAO,CAACa,GAAG,CAAC,2BAA2B,CAAC;;MAExC;MACA,IAAI,OAAOM,MAAM,CAACC,QAAQ,KAAK,UAAU,EAAE;QACzCpB,OAAO,CAACY,KAAK,CAAC,kBAAkB,EAAE,OAAOO,MAAM,CAACC,QAAQ,EAAED,MAAM,CAACC,QAAQ,CAAC;QAC1E,MAAM,IAAIF,KAAK,CAAC,6EAA6E,CAAC;MAChG;MACA,IAAI,OAAOC,MAAM,CAACE,MAAM,KAAK,UAAU,EAAE;QACvCrB,OAAO,CAACY,KAAK,CAAC,gBAAgB,EAAE,OAAOO,MAAM,CAACE,MAAM,EAAEF,MAAM,CAACE,MAAM,CAAC;QACpE,MAAM,IAAIH,KAAK,CAAC,2EAA2E,CAAC;MAC9F;;MAEA;MACA,IAAIC,MAAM,CAAC8B,SAAS,EAAE;QACpBjD,OAAO,CAACa,GAAG,CAAC,8BAA8B,EAAEa,MAAM,CAACwB,IAAI,CAAC/B,MAAM,CAAC8B,SAAS,CAAC,CAAC;MAC5E;;MAEA;MACAjD,OAAO,CAACa,GAAG,CAAC,oDAAoD,CAAC;MACjE,MAAM,IAAIL,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;MAEvD;MACA,IAAI,OAAOU,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACG,MAAM,EAAE;QAClD;QACA,IAAIH,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,WAAW,CAAC,EAAE;UAC7C,OAAOJ,MAAM,CAACG,MAAM,CAACE,SAAS;UAC9BxB,OAAO,CAACa,GAAG,CAAC,mDAAmD,CAAC;QAClE;;QAEA;QACA,IAAI,CAACM,MAAM,CAACG,MAAM,CAACC,cAAc,CAAC,YAAY,CAAC,EAAE;UAC/CG,MAAM,CAACC,cAAc,CAACR,MAAM,CAACG,MAAM,EAAE,YAAY,EAAE;YACjDM,KAAK,EAAE,EAAE;YACTC,QAAQ,EAAE,IAAI;YACdC,UAAU,EAAE,KAAK;YACjBC,YAAY,EAAE;UAChB,CAAC,CAAC;QACJ;MACF;MAEA/B,OAAO,CAACa,GAAG,CAAC,0BAA0B,CAAC;;MAEvC;MACA;MACA;MACA,MAAMsC,eAAe,GAAG,CAAC,CAAC;MAE1B,MAAMC,eAAe,GAAG;QACtBC,UAAU,EAAGC,IAAI,IAAK;UACpBtD,OAAO,CAACa,GAAG,CAAC,+BAA+B,EAAEyC,IAAI,CAAC;;UAElD;UACA,IAAIH,eAAe,CAACG,IAAI,CAAC,EAAE;YACzB,OAAOH,eAAe,CAACG,IAAI,CAAC;UAC9B;UAEA,MAAMC,QAAQ,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC;;UAEtC;UACA,MAAMC,QAAQ,GAAG,yDAAyDH,QAAQ,EAAE;;UAEpF;UACA,MAAMI,WAAW,GAAG,oEAAoEJ,QAAQ,EAAE;;UAElG;UACA,MAAMK,GAAG,GAAGF,QAAQ;UAEpBP,eAAe,CAACG,IAAI,CAAC,GAAGM,GAAG;UAC3B5D,OAAO,CAACa,GAAG,CAAC,wBAAwB,EAAE+C,GAAG,CAAC;UAC1C,OAAOA,GAAG;QACZ,CAAC;QACDC,WAAW,EAAE,CAAC;QACdC,eAAe,EAAE,IAAI;QACrBC,sBAAsB,EAAE,GAAG;QAC3BC,qBAAqB,EAAE;MACzB,CAAC;MAED,IAAIC,eAAe,GAAG,KAAK;MAC3B,IAAIC,QAAQ,GAAG,CAAC;MAChB,MAAMC,WAAW,GAAG,CAAC;MAErB,OAAO,CAACF,eAAe,IAAIC,QAAQ,GAAGC,WAAW,EAAE;QACjD,IAAI;UACFD,QAAQ,EAAE;UACVlE,OAAO,CAACa,GAAG,CAAC,aAAaqD,QAAQ,uBAAuB,CAAC;;UAEzD;UACA,IAAI,OAAO/C,MAAM,CAACC,QAAQ,KAAK,UAAU,EAAE;YACzC,MAAM,IAAIF,KAAK,CAAC,0CAA0C,CAAC;UAC7D;UAEA,IAAI,CAAC/B,QAAQ,GAAG,IAAIgC,MAAM,CAACC,QAAQ,CAACgC,eAAe,CAAC;;UAEpD;UACA,IAAI,CAAC,IAAI,CAACjE,QAAQ,EAAE;YAClB,MAAM,IAAI+B,KAAK,CAAC,yDAAyD,CAAC;UAC5E;;UAEA;UACA,IAAI,OAAO,IAAI,CAAC/B,QAAQ,CAAC2B,UAAU,KAAK,UAAU,EAAE;YAClDd,OAAO,CAACY,KAAK,CAAC,+BAA+B,EAAEc,MAAM,CAACwB,IAAI,CAAC,IAAI,CAAC/D,QAAQ,CAAC,CAAC;YAC1E,MAAM,IAAI+B,KAAK,CAAC,+CAA+C,OAAO,IAAI,CAAC/B,QAAQ,CAAC2B,UAAU,GAAG,CAAC;UACpG;UAEAmD,eAAe,GAAG,IAAI;UACtBjE,OAAO,CAACa,GAAG,CAAC,6BAA6B,CAAC;QAC5C,CAAC,CAAC,OAAOD,KAAK,EAAE;UACd,MAAMwD,QAAQ,GAAGxD,KAAK,CAACyD,OAAO,IAAIzD,KAAK,CAAC0D,QAAQ,CAAC,CAAC;UAClDtE,OAAO,CAACC,IAAI,CAAC,qCAAqCiE,QAAQ,IAAI,EAAEE,QAAQ,CAAC;UACzEpE,OAAO,CAACY,KAAK,CAAC,cAAc,EAAEA,KAAK,CAAC2D,KAAK,CAAC;;UAE1C;UACA,IAAIH,QAAQ,CAACI,QAAQ,CAAC,qBAAqB,CAAC,IAAIJ,QAAQ,CAACI,QAAQ,CAAC,mBAAmB,CAAC,EAAE;YACtFxE,OAAO,CAACC,IAAI,CAAC,4EAA4E,CAAC;;YAE1F;YACA,IAAI;cACF,MAAM,IAAIO,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;cAEvD,MAAMgE,aAAa,GAAG;gBACpBZ,WAAW,EAAE,CAAC;gBACdC,eAAe,EAAE,IAAI;gBACrBC,sBAAsB,EAAE,GAAG;gBAC3BC,qBAAqB,EAAE;cACzB,CAAC;cAED,IAAI,CAAC7E,QAAQ,GAAG,IAAIgC,MAAM,CAACC,QAAQ,CAACqD,aAAa,CAAC;cAElD,IAAI,IAAI,CAACtF,QAAQ,IAAI,OAAO,IAAI,CAACA,QAAQ,CAAC2B,UAAU,KAAK,UAAU,EAAE;gBACnEmD,eAAe,GAAG,IAAI;gBACtBjE,OAAO,CAACa,GAAG,CAAC,oCAAoC,CAAC;gBACjD;cACF;YACF,CAAC,CAAC,OAAO6D,WAAW,EAAE;cACpB1E,OAAO,CAACC,IAAI,CAAC,6CAA6C,EAAEyE,WAAW,CAAC;YAC1E;UACF;UAEA,IAAIR,QAAQ,IAAIC,WAAW,IAAI,CAACF,eAAe,EAAE;YAC/C,MAAM,IAAI/C,KAAK,CAAC,wCAAwCiD,WAAW,gBAAgBC,QAAQ,EAAE,CAAC;UAChG;;UAEA;UACA,MAAM,IAAI5D,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,GAAGyD,QAAQ,CAAC,CAAC;QACpE;MACF;;MAEA;MACA,MAAM,IAAI1D,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;MAEtD,IAAI;QACFT,OAAO,CAACa,GAAG,CAAC,2BAA2B,CAAC;QACxC,MAAM,IAAI,CAAC1B,QAAQ,CAAC2B,UAAU,CAAC,CAAC;QAChCd,OAAO,CAACa,GAAG,CAAC,mCAAmC,CAAC;MAClD,CAAC,CAAC,OAAO8D,SAAS,EAAE;QAClB3E,OAAO,CAACY,KAAK,CAAC,+BAA+B,EAAE+D,SAAS,CAAC;;QAEzD;QACA,IAAI;UACF,IAAI,IAAI,CAACxF,QAAQ,IAAI,OAAO,IAAI,CAACA,QAAQ,CAACyF,KAAK,KAAK,UAAU,EAAE;YAC9D,MAAM,IAAI,CAACzF,QAAQ,CAACyF,KAAK,CAAC,CAAC;UAC7B;;UAEA;UACA,MAAM,IAAIpE,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;UAEvD;UACA,IAAI,CAACtB,QAAQ,GAAG,IAAIgC,MAAM,CAACC,QAAQ,CAACgC,eAAe,CAAC;UACpD,MAAM,IAAI5C,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;UACtD,MAAM,IAAI,CAACtB,QAAQ,CAAC2B,UAAU,CAAC,CAAC;UAChCd,OAAO,CAACa,GAAG,CAAC,qCAAqC,CAAC;QACpD,CAAC,CAAC,OAAOgE,UAAU,EAAE;UACnB7E,OAAO,CAACY,KAAK,CAAC,kCAAkC,EAAEiE,UAAU,CAAC;UAC7D,MAAM,IAAI3D,KAAK,CAAC,iCAAiCyD,SAAS,CAACN,OAAO,sCAAsCQ,UAAU,CAACR,OAAO,EAAE,CAAC;QAC/H;MACF;MAEA,IAAI,CAAClF,QAAQ,CAAC2F,SAAS,CAAEC,OAAO,IAAK;QACnC,IAAI,CAACC,cAAc,CAACD,OAAO,CAAC;MAC9B,CAAC,CAAC;MAEF/E,OAAO,CAACa,GAAG,CAAC,kCAAkC,CAAC;MAC/C,IAAI,CAACxB,aAAa,GAAG,IAAI;IAC3B,CAAC,CAAC,OAAOuB,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAMA,KAAK;IACb;EACF;EAEA+B,UAAUA,CAACD,GAAG,EAAE;IACd,OAAO,IAAIlC,OAAO,CAAC,CAACC,OAAO,EAAEwE,MAAM,KAAK;MACtC;MACA,MAAMC,cAAc,GAAGC,KAAK,CAACC,IAAI,CAACvF,QAAQ,CAACwF,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAACC,IAAI,CACzEC,CAAC,IAAIA,CAAC,CAAC7C,GAAG,KAAKA,GAAG,IAAI6C,CAAC,CAAC7C,GAAG,CAAC8B,QAAQ,CAAC9B,GAAG,CAACc,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAC3D,CAAC;MAED,IAAIyB,cAAc,KAAK/D,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACE,MAAM,CAAC,EAAE;QACxDrB,OAAO,CAACa,GAAG,CAAC,sBAAsB,EAAE6B,GAAG,CAAC;QACxCjC,OAAO,CAAC,CAAC;QACT;MACF;MAEA,MAAM+E,MAAM,GAAG3F,QAAQ,CAAC4F,aAAa,CAAC,QAAQ,CAAC;MAC/CD,MAAM,CAAC9C,GAAG,GAAGA,GAAG;MAChB8C,MAAM,CAACE,WAAW,GAAG,WAAW;MAChCF,MAAM,CAACG,KAAK,GAAG,IAAI;;MAEnB;MACAH,MAAM,CAACI,MAAM,GAAG,MAAM;QACpB;QACA,IAAIzE,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACE,MAAM,IAAIqB,GAAG,CAAC8B,QAAQ,CAAC,WAAW,CAAC,IAAI9B,GAAG,CAAC8B,QAAQ,CAAC,cAAc,CAAC,EAAE;UACjGxE,OAAO,CAACa,GAAG,CAAC,+BAA+B,EAAE6B,GAAG,CAAC;UACjDjC,OAAO,CAAC,CAAC;QACX,CAAC,MAAM;UACL;UACAC,UAAU,CAAC,MAAM;YACf,IAAIS,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACE,MAAM,EAAE;cACpCZ,OAAO,CAAC,CAAC;YACX,CAAC,MAAM;cACLwE,MAAM,CAAC,IAAI/D,KAAK,CAAC,UAAUwB,GAAG,iDAAiD,CAAC,CAAC;YACnF;UACF,CAAC,EAAE,IAAI,CAAC;QACV;MACF,CAAC;MAED8C,MAAM,CAACK,OAAO,GAAIjF,KAAK,IAAK;QAC1BZ,OAAO,CAACY,KAAK,CAAC,0BAA0B,EAAE8B,GAAG,EAAE9B,KAAK,CAAC;QACrDqE,MAAM,CAAC,IAAI/D,KAAK,CAAC,qBAAqBwB,GAAG,gDAAgD,CAAC,CAAC;MAC7F,CAAC;MAED7C,QAAQ,CAACiG,IAAI,CAACC,WAAW,CAACP,MAAM,CAAC;IACnC,CAAC,CAAC;EACJ;EAEAR,cAAcA,CAACD,OAAO,EAAE;IACtB,IAAI,CAACA,OAAO,CAACiB,kBAAkB,IAAIjB,OAAO,CAACiB,kBAAkB,CAAC5F,MAAM,KAAK,CAAC,EAAE;MAC1E,IAAI,CAAC3B,iBAAiB,CAAC;QACrBwH,YAAY,EAAE,KAAK;QACnBC,YAAY,EAAE,KAAK;QACnBC,YAAY,EAAE,CAAC;QACftH,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BC,SAAS,EAAE,IAAI,CAACA;MAClB,CAAC,CAAC;MACF;IACF;IAEA,MAAMsH,SAAS,GAAGrB,OAAO,CAACiB,kBAAkB,CAAC,CAAC,CAAC;IAC/C,MAAMK,cAAc,GAAG,IAAI,CAACC,YAAY,CAACF,SAAS,CAAC;IACnD,MAAMG,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAACJ,SAAS,CAAC;IACpD,MAAMK,aAAa,GAAG,IAAI,CAACC,YAAY,CAACN,SAAS,CAAC;;IAElD;IACA,IAAIC,cAAc,GAAG,GAAG,EAAE;MACxB,MAAMM,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MAC9B,IAAIF,WAAW,GAAG,IAAI,CAAChI,aAAa,GAAG,GAAG,EAAE;QAC1C,IAAI,CAACE,UAAU,EAAE;QACjB,IAAI,CAACF,aAAa,GAAGgI,WAAW;MAClC;IACF;;IAEA;IACA,IAAIJ,SAAS,GAAG,GAAG,EAAE;MACnB,MAAMI,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MAC9B,IAAIF,WAAW,GAAG,IAAI,CAAC5H,YAAY,GAAG,IAAI,EAAE;QAC1C,IAAI,CAACD,SAAS,EAAE;QAChB,IAAI,CAACC,YAAY,GAAG4H,WAAW;MACjC;IACF;;IAEA;IACA,MAAMR,YAAY,GAAG,IAAI,CAACW,gBAAgB,CAACT,cAAc,EAAEE,SAAS,EAAE,IAAI,CAAC1H,UAAU,CAAC;;IAEtF;IACA,MAAMkI,cAAc,GAAGN,aAAa,CAACO,CAAC,GAAG,CAAC,GAAG,IAAIP,aAAa,CAACO,CAAC,GAAG,GAAG,IAC/CP,aAAa,CAACQ,CAAC,GAAG,CAAC,GAAG,IAAIR,aAAa,CAACQ,CAAC,GAAG,GAAG;IAEtE,IAAI,CAACF,cAAc,EAAE;MACnB,IAAI,CAAC7H,aAAa,EAAE;IACtB;IAEA,IAAI,CAACT,iBAAiB,CAAC;MACrBwH,YAAY,EAAE,IAAI;MAClBC,YAAY,EAAEa,cAAc;MAC5BZ,YAAY,EAAEe,IAAI,CAACC,GAAG,CAAChB,YAAY,EAAE,GAAG,CAAC;MACzCtH,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBsI,cAAc,EAAEL,cAAc,GAAG,GAAG,GAAG;IACzC,CAAC,CAAC;EACJ;EAEAT,YAAYA,CAACF,SAAS,EAAE;IACtB,IAAI;MACF,MAAMiB,OAAO,GAAG,IAAI,CAACC,iBAAiB,CAAC,CACrClB,SAAS,CAAC,EAAE,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAC7CA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,CAC/C,CAAC;MAEF,MAAMmB,QAAQ,GAAG,IAAI,CAACD,iBAAiB,CAAC,CACtClB,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAC9CA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,EAAEA,SAAS,CAAC,GAAG,CAAC,CAC/C,CAAC;MAEF,OAAO,CAACiB,OAAO,GAAGE,QAAQ,IAAI,CAAC;IACjC,CAAC,CAAC,OAAO3G,KAAK,EAAE;MACdZ,OAAO,CAACC,IAAI,CAAC,uBAAuB,EAAEW,KAAK,CAAC;MAC5C,OAAO,GAAG,CAAC,CAAC;IACd;EACF;EAEA0G,iBAAiBA,CAACE,SAAS,EAAE;IAC3B,MAAMC,aAAa,GAAG,IAAI,CAACC,QAAQ,CAACF,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;IAC/D,MAAMG,aAAa,GAAG,IAAI,CAACD,QAAQ,CAACF,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;IAC/D,MAAMI,cAAc,GAAG,IAAI,CAACF,QAAQ,CAACF,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;IAEhE,OAAO,CAACC,aAAa,GAAGE,aAAa,KAAK,CAAC,GAAGC,cAAc,CAAC;EAC/D;EAEApB,kBAAkBA,CAACJ,SAAS,EAAE;IAC5B;IACA,MAAMyB,QAAQ,GAAGzB,SAAS,CAAC,EAAE,CAAC;IAC9B,MAAM0B,WAAW,GAAG1B,SAAS,CAAC,EAAE,CAAC;IAEjC,MAAM2B,YAAY,GAAGb,IAAI,CAACc,GAAG,CAACH,QAAQ,CAACZ,CAAC,GAAGa,WAAW,CAACb,CAAC,CAAC;IAEzD,OAAOc,YAAY;EACrB;EAEArB,YAAYA,CAACN,SAAS,EAAE;IACtB;IACA,MAAM6B,OAAO,GAAG7B,SAAS,CAAC,CAAC,CAAC;IAC5B,MAAM8B,aAAa,GAAG9B,SAAS,CAAC,EAAE,CAAC;IACnC,MAAM+B,cAAc,GAAG/B,SAAS,CAAC,GAAG,CAAC;IAErC,MAAMgC,KAAK,GAAG,CAACF,aAAa,CAAClB,CAAC,GAAGmB,cAAc,CAACnB,CAAC,IAAI,CAAC,GAAGiB,OAAO,CAACjB,CAAC;IAClE,MAAMqB,KAAK,GAAGJ,OAAO,CAAChB,CAAC,GAAG,CAACiB,aAAa,CAACjB,CAAC,GAAGkB,cAAc,CAAClB,CAAC,IAAI,CAAC;IAElE,OAAO;MAAED,CAAC,EAAEoB,KAAK;MAAEnB,CAAC,EAAEoB;IAAM,CAAC;EAC/B;EAEAvB,gBAAgBA,CAACwB,GAAG,EAAE/B,SAAS,EAAE1H,UAAU,EAAE;IAC3C,IAAI0J,OAAO,GAAG,CAAC;;IAEf;IACA,IAAID,GAAG,GAAG,GAAG,EAAEC,OAAO,IAAI,GAAG,CAAC,KACzB,IAAID,GAAG,GAAG,IAAI,EAAEC,OAAO,IAAI,GAAG;;IAEnC;IACA,IAAIhC,SAAS,GAAG,GAAG,EAAEgC,OAAO,IAAI,GAAG,CAAC,KAC/B,IAAIhC,SAAS,GAAG,GAAG,EAAEgC,OAAO,IAAI,GAAG;;IAExC;IACA,IAAI1J,UAAU,GAAG,EAAE,EAAE0J,OAAO,IAAI,GAAG;IAEnC,OAAOrB,IAAI,CAACC,GAAG,CAACoB,OAAO,EAAE,GAAG,CAAC;EAC/B;EAEAb,QAAQA,CAACc,MAAM,EAAEC,MAAM,EAAE;IACvB,OAAOvB,IAAI,CAACwB,IAAI,CACdxB,IAAI,CAACyB,GAAG,CAACH,MAAM,CAACxB,CAAC,GAAGyB,MAAM,CAACzB,CAAC,EAAE,CAAC,CAAC,GAChCE,IAAI,CAACyB,GAAG,CAACH,MAAM,CAACvB,CAAC,GAAGwB,MAAM,CAACxB,CAAC,EAAE,CAAC,CACjC,CAAC;EACH;EAEA,MAAMtG,KAAKA,CAAA,EAAG;IACZ,IAAI;MACF,IAAI,IAAI,CAACpB,SAAS,EAAE;QAClBS,OAAO,CAACa,GAAG,CAAC,6BAA6B,CAAC;QAC1C;MACF;MAEAb,OAAO,CAACa,GAAG,CAAC,yCAAyC,CAAC;;MAEtD;MACA,MAAM+H,OAAO,GAAG,MAAM7H,SAAS,CAACC,YAAY,CAAC6H,gBAAgB,CAAC,CAAC;MAC/D,MAAMC,YAAY,GAAGF,OAAO,CAACG,MAAM,CAACC,MAAM,IAAIA,MAAM,CAACC,IAAI,KAAK,YAAY,CAAC;MAE3E,IAAIH,YAAY,CAAC1I,MAAM,KAAK,CAAC,EAAE;QAC7B,MAAM,IAAIc,KAAK,CAAC,eAAe,CAAC;MAClC;;MAEA;MACA;MACAlB,OAAO,CAACa,GAAG,CAAC,0CAA0C,CAAC;;MAEvD;MACA,MAAM,IAAI,CAACC,UAAU,CAAC,CAAC;MAEvB,IAAI,CAAC,IAAI,CAAC3B,QAAQ,EAAE;QAClB,MAAM,IAAI+B,KAAK,CAAC,wCAAwC,CAAC;MAC3D;MAEA,MAAMtB,YAAY,GAAGC,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;MAC3D,IAAI,CAACF,YAAY,EAAE;QACjB,MAAM,IAAIsB,KAAK,CAAC,kCAAkC,CAAC;MACrD;;MAEA;MACAQ,MAAM,CAACwH,MAAM,CAACtJ,YAAY,CAACuJ,KAAK,EAAE;QAChCC,OAAO,EAAE,OAAO;QAChBC,QAAQ,EAAE,OAAO;QACjBC,GAAG,EAAE,GAAG;QACRC,IAAI,EAAE,GAAG;QACTC,KAAK,EAAE,KAAK;QACZC,MAAM,EAAE,KAAK;QACbC,OAAO,EAAE;MACX,CAAC,CAAC;MAEF9J,YAAY,CAAC+J,KAAK,GAAG,IAAI;MACzB/J,YAAY,CAACgK,WAAW,GAAG,IAAI;MAC/BhK,YAAY,CAAC8F,WAAW,GAAG,WAAW;MAEtC,IAAI,CAACvE,MAAM,CAACE,MAAM,EAAE;QAClB,MAAM,IAAIH,KAAK,CAAC,qCAAqC,CAAC;MACxD;MAEAlB,OAAO,CAACa,GAAG,CAAC,mCAAmC,CAAC;;MAEhD;MACA,MAAMgJ,UAAU,GAAG,CAAC;MACpB,IAAIC,aAAa,GAAG,KAAK;MAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,IAAI,CAACC,aAAa,EAAEC,CAAC,EAAE,EAAE;QACrD,IAAI;UACF;UACA,MAAMzK,MAAM,GAAG,MAAMyB,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;YACvD+I,KAAK,EAAE;cACLR,KAAK,EAAE;gBAAES,KAAK,EAAE;cAAI,CAAC;cACrBR,MAAM,EAAE;gBAAEQ,KAAK,EAAE;cAAI,CAAC;cACtBC,UAAU,EAAE,MAAM;cAClBC,SAAS,EAAE;gBAAEF,KAAK,EAAE;cAAG;YACzB,CAAC;YACDG,KAAK,EAAE;UACT,CAAC,CAAC;;UAEF;UACA,IAAI,CAAC9K,MAAM,GAAGA,MAAM;;UAEpB;UACA,IAAIM,YAAY,CAACG,SAAS,EAAE;YAC1B,MAAMsK,SAAS,GAAGzK,YAAY,CAACG,SAAS,CAACI,cAAc,CAAC,CAAC;YACzDkK,SAAS,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAChK,IAAI,CAAC,CAAC,CAAC;UAC1C;;UAEA;UACAX,YAAY,CAACG,SAAS,GAAGT,MAAM;;UAE/B;UACA,MAAM,IAAIkB,OAAO,CAAC,CAACC,OAAO,EAAEwE,MAAM,KAAK;YACrC,MAAMuF,OAAO,GAAG9J,UAAU,CAAC,MAAM;cAC/BuE,MAAM,CAAC,IAAI/D,KAAK,CAAC,oCAAoC,CAAC,CAAC;YACzD,CAAC,EAAE,IAAI,CAAC;YAER,MAAMuJ,SAAS,GAAGA,CAAA,KAAM;cACtBC,YAAY,CAACF,OAAO,CAAC;cACrB5K,YAAY,CAAC+K,mBAAmB,CAAC,SAAS,EAAEF,SAAS,CAAC;cACtDhK,OAAO,CAAC,CAAC;YACX,CAAC;YAEDb,YAAY,CAACgL,gBAAgB,CAAC,SAAS,EAAEH,SAAS,EAAE;cAAEI,IAAI,EAAE;YAAK,CAAC,CAAC;YACnEjL,YAAY,CAACgL,gBAAgB,CAAC,OAAO,EAAGE,CAAC,IAAK;cAAA,IAAAC,mBAAA;cAC5CL,YAAY,CAACF,OAAO,CAAC;cACrBvF,MAAM,CAAC,IAAI/D,KAAK,CAAC,2BAA2B,EAAA6J,mBAAA,GAAAnL,YAAY,CAACgB,KAAK,cAAAmK,mBAAA,uBAAlBA,mBAAA,CAAoB1G,OAAO,KAAI,mBAAmB,EAAE,CAAC,CAAC;YACpG,CAAC,EAAE;cAAEwG,IAAI,EAAE;YAAK,CAAC,CAAC;YAElBjL,YAAY,CAACoL,IAAI,CAAC,CAAC,CAAC,CAAC;UACvB,CAAC,CAAC;UAEF,MAAMpL,YAAY,CAACqL,IAAI,CAAC,CAAC;;UAEzB;UACA,IAAI,CAAC7L,MAAM,GAAG,IAAI+B,MAAM,CAACE,MAAM,CAACzB,YAAY,EAAE;YAC5CsL,OAAO,EAAE,MAAAA,CAAA,KAAY;cACnB,IAAI,IAAI,CAAC/L,QAAQ,IAAIS,YAAY,CAACS,UAAU,KAAK,CAAC,EAAE;gBAClD,IAAI;kBACF,MAAM,IAAI,CAAClB,QAAQ,CAACgM,IAAI,CAAC;oBAAEC,KAAK,EAAExL;kBAAa,CAAC,CAAC;gBACnD,CAAC,CAAC,OAAOgB,KAAK,EAAE;kBACd,IAAI,CAACA,KAAK,CAACyD,OAAO,CAACG,QAAQ,CAAC,yBAAyB,CAAC,EAAE;oBACtDxE,OAAO,CAACC,IAAI,CAAC,iCAAiC,EAAEW,KAAK,CAAC;kBACxD;gBACF;cACF;YACF,CAAC;YACD4I,KAAK,EAAE,GAAG;YACVC,MAAM,EAAE;UACV,CAAC,CAAC;;UAEF;UACA,IAAI4B,aAAa,GAAG,CAAC;UACrB,MAAMC,gBAAgB,GAAG,CAAC;UAE1B,OAAOD,aAAa,GAAGC,gBAAgB,EAAE;YACvC,IAAI;cACF,MAAM9K,OAAO,CAAC+K,IAAI,CAAC,CACjB,IAAI,CAACnM,MAAM,CAACuB,KAAK,CAAC,CAAC,EACnB,IAAIH,OAAO,CAAC,CAACgL,CAAC,EAAEvG,MAAM,KACpBvE,UAAU,CAAC,MAAMuE,MAAM,CAAC,IAAI/D,KAAK,CAAC,2BAA2B,CAAC,CAAC,EAAE,IAAI,CACvE,CAAC,CACF,CAAC;cACF4I,aAAa,GAAG,IAAI;cACpB9J,OAAO,CAACa,GAAG,CAAC,6BAA6B,CAAC;cAC1C;YACF,CAAC,CAAC,OAAO4K,UAAU,EAAE;cACnBJ,aAAa,EAAE;cACfrL,OAAO,CAACC,IAAI,CAAC,aAAaoL,aAAa,4BAA4B,EAAEI,UAAU,CAAC;cAChF,IAAIJ,aAAa,KAAKC,gBAAgB,EAAE,MAAMG,UAAU;cACxD,MAAM,IAAIjL,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;YACzD;UACF;QACF,CAAC,CAAC,OAAOG,KAAK,EAAE;UACdZ,OAAO,CAACC,IAAI,CAAC,aAAa8J,CAAC,GAAG,CAAC,OAAOF,UAAU,UAAU,EAAEjJ,KAAK,CAAC;;UAElE;UACA,IAAI,IAAI,CAACxB,MAAM,EAAE;YACf,IAAI;cACF,IAAI,CAACA,MAAM,CAACmB,IAAI,CAAC,CAAC;cAClB,IAAI,CAACnB,MAAM,GAAG,IAAI;YACpB,CAAC,CAAC,OAAO0L,CAAC,EAAE;cACV9K,OAAO,CAACC,IAAI,CAAC,uBAAuB,EAAE6K,CAAC,CAAC;YAC1C;UACF;;UAEA;UACA,IAAIlL,YAAY,CAACG,SAAS,EAAE;YAC1B,MAAMG,MAAM,GAAGN,YAAY,CAACG,SAAS,CAACI,cAAc,CAAC,CAAC;YACtDD,MAAM,CAACoK,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAChK,IAAI,CAAC,CAAC,CAAC;YACrCX,YAAY,CAACG,SAAS,GAAG,IAAI;YAC7B,IAAI,CAACT,MAAM,GAAG,IAAI;UACpB;UAEA,IAAIyK,CAAC,KAAKF,UAAU,GAAG,CAAC,EAAE;YACxB,IAAI,CAACtK,SAAS,GAAG,KAAK;YACtB,MAAMqB,KAAK;UACb;UACA,MAAM,IAAIJ,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,IAAIsJ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACnE;MACF;;MAEA;MACA,MAAM,IAAIvJ,OAAO,CAAC,CAACC,OAAO,EAAEwE,MAAM,KAAK;QACrC,MAAMuF,OAAO,GAAG9J,UAAU,CAAC,MAAM;UAC/BuE,MAAM,CAAC,IAAI/D,KAAK,CAAC,oCAAoC,CAAC,CAAC;QACzD,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;QAEX,MAAMwK,UAAU,GAAGA,CAAA,KAAM;UACvB,IAAI9L,YAAY,CAAC+L,UAAU,GAAG,CAAC,IAAI/L,YAAY,CAACgM,WAAW,GAAG,CAAC,EAAE;YAC/DlB,YAAY,CAACF,OAAO,CAAC;YACrB/J,OAAO,CAAC,CAAC;UACX,CAAC,MAAM;YACLoL,qBAAqB,CAACH,UAAU,CAAC;UACnC;QACF,CAAC;;QAED;QACA,IAAI9L,YAAY,CAAC+L,UAAU,GAAG,CAAC,IAAI/L,YAAY,CAACgM,WAAW,GAAG,CAAC,EAAE;UAC/DlB,YAAY,CAACF,OAAO,CAAC;UACrB/J,OAAO,CAAC,CAAC;QACX,CAAC,MAAM;UACLb,YAAY,CAACgL,gBAAgB,CAAC,SAAS,EAAEc,UAAU,EAAE;YAAEb,IAAI,EAAE;UAAK,CAAC,CAAC;UACpEjL,YAAY,CAACgL,gBAAgB,CAAC,gBAAgB,EAAEc,UAAU,EAAE;YAAEb,IAAI,EAAE;UAAK,CAAC,CAAC;UAC3EjL,YAAY,CAACgL,gBAAgB,CAAC,OAAO,EAAGE,CAAC,IAAK;YAAA,IAAAgB,oBAAA;YAC5CpB,YAAY,CAACF,OAAO,CAAC;YACrBvF,MAAM,CAAC,IAAI/D,KAAK,CAAC,8BAA8B,EAAA4K,oBAAA,GAAAlM,YAAY,CAACgB,KAAK,cAAAkL,oBAAA,uBAAlBA,oBAAA,CAAoBzH,OAAO,KAAI,mBAAmB,EAAE,CAAC,CAAC;UACvG,CAAC,EAAE;YAAEwG,IAAI,EAAE;UAAK,CAAC,CAAC;QACpB;MACF,CAAC,CAAC;;MAEF;MACA,IAAI,CAACtL,SAAS,GAAG,IAAI;;MAErB;MACA,IAAI,CAACD,MAAM,GAAGM,YAAY,CAACG,SAAS;;MAEpC;MACA,IAAI,CAAC,IAAI,CAACP,mBAAmB,EAAE;QAC7B,IAAI,CAACE,gBAAgB,CAAC,CAAC;MACzB;MAEA,IAAI,IAAI,CAAChB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,CAAC,OAAOkC,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;;MAE/C;MACA,IAAImL,WAAW,GAAG,8CAA8C;MAChE,IAAInL,KAAK,CAACoL,IAAI,KAAK,iBAAiB,IAAIpL,KAAK,CAACyD,OAAO,CAACG,QAAQ,CAAC,mBAAmB,CAAC,EAAE;QACnFuH,WAAW,IAAI,yFAAyF;MAC1G,CAAC,MAAM,IAAInL,KAAK,CAACoL,IAAI,KAAK,eAAe,IAAIpL,KAAK,CAACyD,OAAO,CAACG,QAAQ,CAAC,4BAA4B,CAAC,EAAE;QACjGuH,WAAW,IAAI,sEAAsE;MACvF,CAAC,MAAM,IAAInL,KAAK,CAACoL,IAAI,KAAK,kBAAkB,IAAIpL,KAAK,CAACyD,OAAO,CAACG,QAAQ,CAAC,8BAA8B,CAAC,EAAE;QACtGuH,WAAW,IAAI,yGAAyG;MAC1H,CAAC,MAAM,IAAInL,KAAK,CAACoL,IAAI,KAAK,mBAAmB,EAAE;QAC7CD,WAAW,IAAI,qFAAqF;MACtG,CAAC,MAAM,IAAInL,KAAK,CAACyD,OAAO,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;QAC5CuH,WAAW,IAAI,uEAAuE;MACxF,CAAC,MAAM;QACLA,WAAW,IAAInL,KAAK,CAACyD,OAAO,IAAI,wCAAwC;MAC1E;MAEArE,OAAO,CAACC,IAAI,CAAC8L,WAAW,CAAC;;MAEzB;MACA,IAAI,CAACxM,SAAS,GAAG,KAAK;MACtB,IAAI,CAACE,cAAc,GAAG,KAAK;MAC3B,IAAI,IAAI,CAACH,MAAM,EAAE;QACf,MAAMY,MAAM,GAAG,IAAI,CAACZ,MAAM,CAACa,cAAc,CAAC,CAAC;QAC3CD,MAAM,CAACoK,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAChK,IAAI,CAAC,CAAC,CAAC;QACrC,IAAI,CAACjB,MAAM,GAAG,IAAI;MACpB;;MAEA;MACA,MAAMM,YAAY,GAAGC,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;MAC3D,IAAIF,YAAY,IAAIA,YAAY,CAACG,SAAS,EAAE;QAC1C,MAAMG,MAAM,GAAGN,YAAY,CAACG,SAAS,CAACI,cAAc,CAAC,CAAC;QACtDD,MAAM,CAACoK,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAChK,IAAI,CAAC,CAAC,CAAC;QACrCX,YAAY,CAACG,SAAS,GAAG,IAAI;MAC/B;MAEA,MAAMa,KAAK,CAAC,CAAE;IAChB;EACF;EAEAqL,iBAAiBA,CAAA,EAAG;IAClBjM,OAAO,CAACa,GAAG,CAAC,4CAA4C,CAAC;IACzD;IACA,IAAI,CAACqL,kBAAkB,GAAGvM,WAAW,CAAC,MAAM;MAC1C,MAAMoH,cAAc,GAAGG,IAAI,CAACiF,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;MAC5C,MAAMhG,YAAY,GAAGe,IAAI,CAACiF,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;MAC1C,MAAMC,cAAc,GAAGlF,IAAI,CAACmF,KAAK,CAACnF,IAAI,CAACiF,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;MAEtD,IAAI,CAACtN,UAAU,IAAIuN,cAAc;MAEjC,IAAI,CAAC3N,iBAAiB,CAAC;QACrBwH,YAAY,EAAE,IAAI;QAClBC,YAAY,EAAEa,cAAc;QAC5BZ,YAAY,EAAEA,YAAY;QAC1BtH,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BC,SAAS,EAAE,IAAI,CAACA,SAAS;QACzBsI,cAAc,EAAEL,cAAc,GAAI,GAAG,GAAGZ,YAAY,GAAG,GAAG,GAAI;MAChE,CAAC,CAAC;IACJ,CAAC,EAAE,IAAI,CAAC;EACV;EAEA,MAAM5F,IAAIA,CAAA,EAAG;IACX,IAAI;MACF;MACA,IAAI,IAAI,CAACf,mBAAmB,EAAE;QAC5B8M,aAAa,CAAC,IAAI,CAAC9M,mBAAmB,CAAC;QACvC,IAAI,CAACA,mBAAmB,GAAG,IAAI;MACjC;;MAEA;MACA,IAAI,IAAI,CAACJ,MAAM,EAAE;QACf,IAAI;UACF,MAAM,IAAI,CAACA,MAAM,CAACmB,IAAI,CAAC,CAAC;QAC1B,CAAC,CAAC,OAAOK,KAAK,EAAE;UACdZ,OAAO,CAACC,IAAI,CAAC,iCAAiC,EAAEW,KAAK,CAAC;QACxD;QACA,IAAI,CAACxB,MAAM,GAAG,IAAI;MACpB;;MAEA;MACA,IAAI,IAAI,CAACD,QAAQ,EAAE;QACjB,IAAI;UACF,MAAM,IAAI,CAACA,QAAQ,CAACyF,KAAK,CAAC,CAAC;QAC7B,CAAC,CAAC,OAAOhE,KAAK,EAAE;UACdZ,OAAO,CAACC,IAAI,CAAC,0BAA0B,EAAEW,KAAK,CAAC;QACjD;QACA,IAAI,CAACzB,QAAQ,GAAG,IAAI;MACtB;MAEA,IAAI,CAACE,aAAa,GAAG,KAAK;MAC1B,IAAI,CAACE,SAAS,GAAG,KAAK;MACtB,IAAI,CAACE,cAAc,GAAG,KAAK;;MAE3B;MACA,IAAI,IAAI,CAACH,MAAM,EAAE;QACf,MAAMY,MAAM,GAAG,IAAI,CAACZ,MAAM,CAACa,cAAc,CAAC,CAAC;QAC3CD,MAAM,CAACoK,OAAO,CAACC,KAAK,IAAI;UACtBA,KAAK,CAAChK,IAAI,CAAC,CAAC;QACd,CAAC,CAAC;QACF,IAAI,CAACjB,MAAM,GAAG,IAAI;MACpB;;MAEA;MACA,MAAMM,YAAY,GAAGC,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;MAC3D,IAAIF,YAAY,EAAE;QAChB,IAAIA,YAAY,CAACG,SAAS,EAAE;UAC1B,MAAMG,MAAM,GAAGN,YAAY,CAACG,SAAS,CAACI,cAAc,CAAC,CAAC;UACtDD,MAAM,CAACoK,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAChK,IAAI,CAAC,CAAC,CAAC;QACvC;QACAX,YAAY,CAACG,SAAS,GAAG,IAAI;QAC7BH,YAAY,CAACoL,IAAI,CAAC,CAAC;MACrB;MAEAhL,OAAO,CAACa,GAAG,CAAC,+CAA+C,CAAC;IAC9D,CAAC,CAAC,OAAOD,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,IAAI,CAACrB,SAAS,GAAG,KAAK;IACxB;EACF;EAEAgN,aAAaA,CAAA,EAAG;IACd,IAAI,CAAC1N,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACI,aAAa,GAAG,CAAC;EACxB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}