{"ast":null,"code":"// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n    this.stream = null;\n    this.isRunning = false;\n    this.healthCheckInterval = null;\n\n    // Iniciar verificação periódica do estado da câmera\n    this.startHealthCheck();\n  }\n  startHealthCheck() {\n    this.healthCheckInterval = setInterval(async () => {\n      if (this.isRunning) {\n        const videoElement = document.getElementById('input_video');\n        if (!videoElement || !videoElement.srcObject || videoElement.readyState !== 4) {\n          console.warn('Problema detectado com a câmera, tentando reconectar...');\n          try {\n            await this.stop();\n            await this.start();\n          } catch (error) {\n            console.error('Falha ao reconectar câmera:', error);\n          }\n        }\n      }\n    }, 5000); // Verificar a cada 5 segundos\n  }\n  async initialize() {\n    if (this.isInitialized) return;\n    try {\n      console.log('Iniciando carregamento do MediaPipe...');\n\n      // Verificar suporte do navegador\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Este navegador não suporta acesso à câmera');\n      }\n\n      // Verificar se o MediaPipe já foi carregado\n      if (typeof window !== 'undefined' && window.FaceMesh && window.Camera) {\n        console.log('MediaPipe já está carregado');\n      } else {\n        console.log('Carregando MediaPipe...');\n        // Carregar scripts com retry\n        const maxRetries = 3;\n        let loaded = false;\n        for (let i = 0; i < maxRetries && !loaded; i++) {\n          try {\n            await Promise.all([this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js'), this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js')]);\n\n            // Aguardar um curto período para garantir que os scripts foram processados\n            await new Promise(resolve => setTimeout(resolve, 500));\n            if (typeof window !== 'undefined' && window.FaceMesh && window.Camera) {\n              loaded = true;\n              console.log('MediaPipe carregado com sucesso');\n            } else {\n              throw new Error('MediaPipe não foi carregado corretamente');\n            }\n          } catch (error) {\n            console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n            if (i === maxRetries - 1) throw error;\n            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n          }\n        }\n      }\n      console.log('Configurando FaceMesh...');\n      this.faceMesh = new window.FaceMesh({\n        locateFile: file => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n      await this.faceMesh.initialize();\n      this.faceMesh.onResults(results => {\n        this.processResults(results);\n      });\n      console.log('FaceMesh configurado com sucesso');\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Erro na inicialização:', error);\n      throw error;\n    }\n  }\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  }\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n  calculateEAR(landmarks) {\n    try {\n      const leftEAR = this.getEyeAspectRatio([landmarks[33], landmarks[133], landmarks[157], landmarks[158], landmarks[159], landmarks[160]]);\n      const rightEAR = this.getEyeAspectRatio([landmarks[362], landmarks[385], landmarks[386], landmarks[387], landmarks[388], landmarks[466]]);\n      return (leftEAR + rightEAR) / 2;\n    } catch (error) {\n      console.warn('Erro ao calcular EAR:', error);\n      return 0.3; // valor padrão seguro\n    }\n  }\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    return mouthOpening;\n  }\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n    return {\n      x: gazeX,\n      y: gazeY\n    };\n  }\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n    return Math.min(fatigue, 1.0);\n  }\n  distance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n  }\n  async start() {\n    try {\n      if (this.isRunning) {\n        console.log('Sistema já está em execução');\n        return;\n      }\n      console.log('Iniciando sistema de detecção facial...');\n\n      // Verificar disponibilidade de câmera\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      if (videoDevices.length === 0) {\n        throw new Error('NotFoundError');\n      }\n\n      // Solicitar permissão da câmera\n      let stream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 640\n            },\n            height: {\n              ideal: 480\n            },\n            facingMode: \"user\",\n            frameRate: {\n              ideal: 30\n            }\n          },\n          audio: false\n        });\n        this.stream = stream;\n        console.log('Permissão da câmera concedida');\n      } catch (error) {\n        console.error('Erro ao solicitar permissão da câmera:', error);\n        throw error;\n      }\n\n      // Liberar a stream inicial após verificar que está funcionando\n      const track = stream.getVideoTracks()[0];\n      const settings = track.getSettings();\n      console.log('Configurações da câmera:', settings);\n      if (!settings.width || !settings.height) {\n        track.stop();\n        throw new Error('NotSupportedError');\n      }\n      track.stop();\n\n      // Inicializar MediaPipe\n      await this.initialize();\n      if (!this.faceMesh) {\n        throw new Error('MediaPipe não inicializou corretamente');\n      }\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        throw new Error('Elemento de vídeo não encontrado');\n      }\n\n      // Configurar elemento de vídeo\n      Object.assign(videoElement.style, {\n        display: 'block',\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '1px',\n        height: '1px',\n        opacity: '0.01'\n      });\n      videoElement.muted = true;\n      videoElement.playsInline = true;\n      videoElement.crossOrigin = 'anonymous';\n      if (!window.Camera) {\n        throw new Error('MediaPipe Camera API não disponível');\n      }\n      console.log('Iniciando câmera com MediaPipe...');\n\n      // Criar e configurar câmera com retry e timeout\n      const maxRetries = 3;\n      let cameraStarted = false;\n      for (let i = 0; i < maxRetries && !cameraStarted; i++) {\n        try {\n          // Primeiro, tentar obter um stream de vídeo diretamente\n          const stream = await navigator.mediaDevices.getUserMedia({\n            video: {\n              width: {\n                ideal: 640\n              },\n              height: {\n                ideal: 480\n              },\n              facingMode: \"user\",\n              frameRate: {\n                ideal: 30\n              }\n            }\n          });\n\n          // Atribuir o stream ao elemento de vídeo\n          videoElement.srcObject = stream;\n          await videoElement.play();\n\n          // Configurar a câmera do MediaPipe\n          this.camera = new window.Camera(videoElement, {\n            onFrame: async () => {\n              if (this.faceMesh && videoElement.readyState === 4) {\n                try {\n                  await this.faceMesh.send({\n                    image: videoElement\n                  });\n                } catch (error) {\n                  if (!error.message.includes('Canvas has been cleared')) {\n                    console.warn('Erro no processamento do frame:', error);\n                  }\n                }\n              }\n            },\n            width: 640,\n            height: 480\n          });\n\n          // Iniciar o processamento da câmera com retry em caso de falha\n          let startAttempts = 0;\n          const maxStartAttempts = 3;\n          while (startAttempts < maxStartAttempts) {\n            try {\n              await Promise.race([this.camera.start(), new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout ao iniciar câmera')), 5000))]);\n              cameraStarted = true;\n              console.log('Câmera iniciada com sucesso');\n              break;\n            } catch (startError) {\n              startAttempts++;\n              console.warn(`Tentativa ${startAttempts} de iniciar câmera falhou:`, startError);\n              if (startAttempts === maxStartAttempts) throw startError;\n              await new Promise(resolve => setTimeout(resolve, 1000));\n            }\n          }\n        } catch (error) {\n          console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n          if (this.camera) {\n            try {\n              this.camera.stop();\n            } catch (e) {\n              console.warn('Erro ao parar câmera:', e);\n            }\n          }\n          if (i === maxRetries - 1) throw error;\n          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n      }\n\n      // Verificar se o vídeo está recebendo frames\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Timeout aguardando frames de vídeo'));\n        }, 5000);\n        const checkVideo = () => {\n          if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n            clearTimeout(timeout);\n            resolve();\n          } else {\n            requestAnimationFrame(checkVideo);\n          }\n        };\n        videoElement.addEventListener('playing', checkVideo, {\n          once: true\n        });\n        videoElement.addEventListener('error', e => {\n          clearTimeout(timeout);\n          reject(new Error(`Erro no elemento de vídeo: ${videoElement.error.message}`));\n        }, {\n          once: true\n        });\n      });\n      if (this.onReady) {\n        this.onReady();\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n\n      // Informar o usuário sobre o problema específico\n      let userMessage = 'Erro ao iniciar o sistema de monitoramento: ';\n      if (error.name === 'NotAllowedError' || error.message.includes('Permission denied')) {\n        userMessage += 'Permissão da câmera negada. Por favor, permita o acesso à câmera e recarregue a página.';\n      } else if (error.name === 'NotFoundError' || error.message.includes('Requested device not found')) {\n        userMessage += 'Nenhuma câmera encontrada. Conecte uma câmera e recarregue a página.';\n      } else if (error.name === 'NotReadableError' || error.message.includes('Could not start video source')) {\n        userMessage += 'Câmera pode estar em uso por outro aplicativo. Feche outros programas que possam estar usando a câmera.';\n      } else if (error.name === 'NotSupportedError') {\n        userMessage += 'Sua câmera não é compatível com os requisitos necessários. Tente usar outra câmera.';\n      } else if (error.message.includes('Timeout')) {\n        userMessage += 'Tempo excedido ao tentar acessar a câmera. Tente recarregar a página.';\n      } else {\n        userMessage += error.message || 'Erro desconhecido ao acessar a câmera.';\n      }\n      console.warn(userMessage);\n      throw error; // Vamos deixar o StudentView lidar com o erro\n    }\n  }\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? 1.0 - fatigueScore * 0.5 : 0.0\n      });\n    }, 2000);\n  }\n  async stop() {\n    try {\n      if (this.camera) {\n        await this.camera.stop();\n        this.camera = null;\n      }\n      if (this.faceMesh) {\n        await this.faceMesh.close();\n        this.faceMesh = null;\n      }\n      this.isInitialized = false;\n\n      // Limpar o elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement) {\n        videoElement.srcObject = null;\n        videoElement.load();\n      }\n      console.log('Sistema de detecção facial parado com sucesso');\n    } catch (error) {\n      console.error('Erro ao parar o sistema:', error);\n    }\n  }\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}","map":{"version":3,"names":["FaceDetectionSystem","constructor","onDetectionUpdate","onReady","lastBlinkTime","earHistory","blinkCount","yawnCount","lastYawnTime","eyeOpenTime","stressScore","gazeOffScreen","faceMesh","camera","isInitialized","stream","isRunning","healthCheckInterval","startHealthCheck","setInterval","videoElement","document","getElementById","srcObject","readyState","console","warn","stop","start","error","initialize","log","navigator","mediaDevices","getUserMedia","Error","window","FaceMesh","Camera","maxRetries","loaded","i","Promise","all","loadScript","resolve","setTimeout","locateFile","file","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","processResults","src","reject","script","createElement","onload","onerror","head","appendChild","multiFaceLandmarks","length","faceDetected","gazeOnScreen","fatigueScore","landmarks","eyeAspectRatio","calculateEAR","yawnRatio","calculateYawnRatio","gazeDirection","estimateGaze","currentTime","Date","now","calculateFatigue","isGazeOnScreen","x","y","Math","min","attentionScore","leftEAR","getEyeAspectRatio","rightEAR","eyePoints","verticalDist1","distance","verticalDist2","horizontalDist","mouthTop","mouthBottom","mouthOpening","abs","noseTip","leftEyeCenter","rightEyeCenter","gazeX","gazeY","EAR","fatigue","point1","point2","sqrt","pow","devices","enumerateDevices","videoDevices","filter","device","kind","video","width","ideal","height","facingMode","frameRate","audio","track","getVideoTracks","settings","getSettings","Object","assign","style","display","position","top","left","opacity","muted","playsInline","crossOrigin","cameraStarted","play","onFrame","send","image","message","includes","startAttempts","maxStartAttempts","race","_","startError","e","timeout","checkVideo","videoWidth","videoHeight","clearTimeout","requestAnimationFrame","addEventListener","once","userMessage","name","simulateDetection","simulationInterval","random","blinkIncrement","floor","close","load","resetCounters"],"sources":["/Users/macbookair/Documents/GitHub/Sistema-de-Monitoramento-de-Engajamento-em-Aulas-Online/frontend/src/utils/FaceDetection.js"],"sourcesContent":["// FaceDetection using MediaPipe via CDN\n\nexport class FaceDetectionSystem {\n  constructor(onDetectionUpdate, onReady) {\n    this.onDetectionUpdate = onDetectionUpdate;\n    this.onReady = onReady;\n\n    this.lastBlinkTime = 0;\n    this.earHistory = [];\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.lastYawnTime = 0;\n    this.eyeOpenTime = 0;\n    this.stressScore = 0;\n    this.gazeOffScreen = 0;\n\n    this.faceMesh = null;\n    this.camera = null;\n    this.isInitialized = false;\n    this.stream = null;\n    this.isRunning = false;\n    this.healthCheckInterval = null;\n\n    // Iniciar verificação periódica do estado da câmera\n    this.startHealthCheck();\n  }\n\n  startHealthCheck() {\n    this.healthCheckInterval = setInterval(async () => {\n      if (this.isRunning) {\n        const videoElement = document.getElementById('input_video');\n        \n        if (!videoElement || !videoElement.srcObject || videoElement.readyState !== 4) {\n          console.warn('Problema detectado com a câmera, tentando reconectar...');\n          try {\n            await this.stop();\n            await this.start();\n          } catch (error) {\n            console.error('Falha ao reconectar câmera:', error);\n          }\n        }\n      }\n    }, 5000); // Verificar a cada 5 segundos\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      console.log('Iniciando carregamento do MediaPipe...');\n      \n      // Verificar suporte do navegador\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Este navegador não suporta acesso à câmera');\n      }\n\n      // Verificar se o MediaPipe já foi carregado\n      if (typeof window !== 'undefined' && window.FaceMesh && window.Camera) {\n        console.log('MediaPipe já está carregado');\n      } else {\n        console.log('Carregando MediaPipe...');\n        // Carregar scripts com retry\n        const maxRetries = 3;\n        let loaded = false;\n        \n        for (let i = 0; i < maxRetries && !loaded; i++) {\n          try {\n            await Promise.all([\n              this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js'),\n              this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js')\n            ]);\n\n            // Aguardar um curto período para garantir que os scripts foram processados\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            if (typeof window !== 'undefined' && window.FaceMesh && window.Camera) {\n              loaded = true;\n              console.log('MediaPipe carregado com sucesso');\n            } else {\n              throw new Error('MediaPipe não foi carregado corretamente');\n            }\n          } catch (error) {\n            console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n            if (i === maxRetries - 1) throw error;\n            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n          }\n        }\n      }\n\n      console.log('Configurando FaceMesh...');\n      \n      this.faceMesh = new window.FaceMesh({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;\n        },\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n\n      await this.faceMesh.initialize();\n\n      this.faceMesh.onResults((results) => {\n        this.processResults(results);\n      });\n\n      console.log('FaceMesh configurado com sucesso');\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Erro na inicialização:', error);\n      throw error;\n    }\n  }\n\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  }\n\n  processResults(results) {\n    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {\n      this.onDetectionUpdate({\n        faceDetected: false,\n        gazeOnScreen: false,\n        fatigueScore: 0,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount\n      });\n      return;\n    }\n\n    const landmarks = results.multiFaceLandmarks[0];\n    const eyeAspectRatio = this.calculateEAR(landmarks);\n    const yawnRatio = this.calculateYawnRatio(landmarks);\n    const gazeDirection = this.estimateGaze(landmarks);\n\n    // Detectar piscadas\n    if (eyeAspectRatio < 0.2) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastBlinkTime > 300) {\n        this.blinkCount++;\n        this.lastBlinkTime = currentTime;\n      }\n    }\n\n    // Detectar bocejos\n    if (yawnRatio > 0.6) {\n      const currentTime = Date.now();\n      if (currentTime - this.lastYawnTime > 2000) {\n        this.yawnCount++;\n        this.lastYawnTime = currentTime;\n      }\n    }\n\n    // Calcular score de fadiga\n    const fatigueScore = this.calculateFatigue(eyeAspectRatio, yawnRatio, this.blinkCount);\n\n    // Detectar desvio de olhar\n    const isGazeOnScreen = gazeDirection.x > -0.3 && gazeDirection.x < 0.3 && \n                           gazeDirection.y > -0.2 && gazeDirection.y < 0.2;\n    \n    if (!isGazeOnScreen) {\n      this.gazeOffScreen++;\n    }\n\n    this.onDetectionUpdate({\n      faceDetected: true,\n      gazeOnScreen: isGazeOnScreen,\n      fatigueScore: Math.min(fatigueScore, 1.0),\n      blinkCount: this.blinkCount,\n      yawnCount: this.yawnCount,\n      attentionScore: isGazeOnScreen ? 1.0 : 0.0\n    });\n  }\n\n  calculateEAR(landmarks) {\n    try {\n      const leftEAR = this.getEyeAspectRatio([\n        landmarks[33], landmarks[133], landmarks[157], \n        landmarks[158], landmarks[159], landmarks[160]\n      ]);\n      \n      const rightEAR = this.getEyeAspectRatio([\n        landmarks[362], landmarks[385], landmarks[386],\n        landmarks[387], landmarks[388], landmarks[466]\n      ]);\n\n      return (leftEAR + rightEAR) / 2;\n    } catch (error) {\n      console.warn('Erro ao calcular EAR:', error);\n      return 0.3; // valor padrão seguro\n    }\n  }\n\n  getEyeAspectRatio(eyePoints) {\n    const verticalDist1 = this.distance(eyePoints[1], eyePoints[5]);\n    const verticalDist2 = this.distance(eyePoints[2], eyePoints[4]);\n    const horizontalDist = this.distance(eyePoints[0], eyePoints[3]);\n\n    return (verticalDist1 + verticalDist2) / (2 * horizontalDist);\n  }\n\n  calculateYawnRatio(landmarks) {\n    // Pontos da boca\n    const mouthTop = landmarks[13];\n    const mouthBottom = landmarks[14];\n\n    const mouthOpening = Math.abs(mouthTop.y - mouthBottom.y);\n    \n    return mouthOpening;\n  }\n\n  estimateGaze(landmarks) {\n    // Estimativa simples do gaze baseada na posição da íris\n    const noseTip = landmarks[4];\n    const leftEyeCenter = landmarks[33];\n    const rightEyeCenter = landmarks[263];\n\n    const gazeX = (leftEyeCenter.x + rightEyeCenter.x) / 2 - noseTip.x;\n    const gazeY = noseTip.y - (leftEyeCenter.y + rightEyeCenter.y) / 2;\n\n    return { x: gazeX, y: gazeY };\n  }\n\n  calculateFatigue(EAR, yawnRatio, blinkCount) {\n    let fatigue = 0;\n\n    // Fadiga por olhos fechados\n    if (EAR < 0.2) fatigue += 0.4;\n    else if (EAR < 0.25) fatigue += 0.2;\n\n    // Fadiga por bocejo\n    if (yawnRatio > 0.6) fatigue += 0.3;\n    else if (yawnRatio > 0.4) fatigue += 0.1;\n\n    // Fadiga por piscadas excessivas\n    if (blinkCount > 20) fatigue += 0.3;\n\n    return Math.min(fatigue, 1.0);\n  }\n\n  distance(point1, point2) {\n    return Math.sqrt(\n      Math.pow(point1.x - point2.x, 2) + \n      Math.pow(point1.y - point2.y, 2)\n    );\n  }\n\n  async start() {\n    try {\n      if (this.isRunning) {\n        console.log('Sistema já está em execução');\n        return;\n      }\n\n      console.log('Iniciando sistema de detecção facial...');\n      \n      // Verificar disponibilidade de câmera\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      \n      if (videoDevices.length === 0) {\n        throw new Error('NotFoundError');\n      }\n      \n      // Solicitar permissão da câmera\n      let stream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({ \n          video: { \n            width: { ideal: 640 },\n            height: { ideal: 480 },\n            facingMode: \"user\",\n            frameRate: { ideal: 30 }\n          },\n          audio: false\n        });\n        this.stream = stream;\n        console.log('Permissão da câmera concedida');\n      } catch (error) {\n        console.error('Erro ao solicitar permissão da câmera:', error);\n        throw error;\n      }\n\n      // Liberar a stream inicial após verificar que está funcionando\n      const track = stream.getVideoTracks()[0];\n      const settings = track.getSettings();\n      console.log('Configurações da câmera:', settings);\n      \n      if (!settings.width || !settings.height) {\n        track.stop();\n        throw new Error('NotSupportedError');\n      }\n      \n      track.stop();\n\n      // Inicializar MediaPipe\n      await this.initialize();\n\n      if (!this.faceMesh) {\n        throw new Error('MediaPipe não inicializou corretamente');\n      }\n\n      const videoElement = document.getElementById('input_video');\n      if (!videoElement) {\n        throw new Error('Elemento de vídeo não encontrado');\n      }\n\n      // Configurar elemento de vídeo\n      Object.assign(videoElement.style, {\n        display: 'block',\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '1px',\n        height: '1px',\n        opacity: '0.01'\n      });\n      \n      videoElement.muted = true;\n      videoElement.playsInline = true;\n      videoElement.crossOrigin = 'anonymous';\n\n      if (!window.Camera) {\n        throw new Error('MediaPipe Camera API não disponível');\n      }\n\n      console.log('Iniciando câmera com MediaPipe...');\n      \n      // Criar e configurar câmera com retry e timeout\n      const maxRetries = 3;\n      let cameraStarted = false;\n      \n      for (let i = 0; i < maxRetries && !cameraStarted; i++) {\n        try {\n          // Primeiro, tentar obter um stream de vídeo diretamente\n          const stream = await navigator.mediaDevices.getUserMedia({\n            video: {\n              width: { ideal: 640 },\n              height: { ideal: 480 },\n              facingMode: \"user\",\n              frameRate: { ideal: 30 }\n            }\n          });\n\n          // Atribuir o stream ao elemento de vídeo\n          videoElement.srcObject = stream;\n          await videoElement.play();\n\n          // Configurar a câmera do MediaPipe\n          this.camera = new window.Camera(videoElement, {\n            onFrame: async () => {\n              if (this.faceMesh && videoElement.readyState === 4) {\n                try {\n                  await this.faceMesh.send({ image: videoElement });\n                } catch (error) {\n                  if (!error.message.includes('Canvas has been cleared')) {\n                    console.warn('Erro no processamento do frame:', error);\n                  }\n                }\n              }\n            },\n            width: 640,\n            height: 480\n          });\n\n          // Iniciar o processamento da câmera com retry em caso de falha\n          let startAttempts = 0;\n          const maxStartAttempts = 3;\n          \n          while (startAttempts < maxStartAttempts) {\n            try {\n              await Promise.race([\n                this.camera.start(),\n                new Promise((_, reject) => \n                  setTimeout(() => reject(new Error('Timeout ao iniciar câmera')), 5000)\n                )\n              ]);\n              cameraStarted = true;\n              console.log('Câmera iniciada com sucesso');\n              break;\n            } catch (startError) {\n              startAttempts++;\n              console.warn(`Tentativa ${startAttempts} de iniciar câmera falhou:`, startError);\n              if (startAttempts === maxStartAttempts) throw startError;\n              await new Promise(resolve => setTimeout(resolve, 1000));\n            }\n          }\n        } catch (error) {\n          console.warn(`Tentativa ${i + 1} de ${maxRetries} falhou:`, error);\n          if (this.camera) {\n            try {\n              this.camera.stop();\n            } catch (e) {\n              console.warn('Erro ao parar câmera:', e);\n            }\n          }\n          if (i === maxRetries - 1) throw error;\n          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n      }\n\n      // Verificar se o vídeo está recebendo frames\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Timeout aguardando frames de vídeo'));\n        }, 5000);\n\n        const checkVideo = () => {\n          if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n            clearTimeout(timeout);\n            resolve();\n          } else {\n            requestAnimationFrame(checkVideo);\n          }\n        };\n\n        videoElement.addEventListener('playing', checkVideo, { once: true });\n        videoElement.addEventListener('error', (e) => {\n          clearTimeout(timeout);\n          reject(new Error(`Erro no elemento de vídeo: ${videoElement.error.message}`));\n        }, { once: true });\n      });\n\n      if (this.onReady) {\n        this.onReady();\n      }\n    } catch (error) {\n      console.error('Erro ao iniciar câmera:', error);\n      \n      // Informar o usuário sobre o problema específico\n      let userMessage = 'Erro ao iniciar o sistema de monitoramento: ';\n      if (error.name === 'NotAllowedError' || error.message.includes('Permission denied')) {\n        userMessage += 'Permissão da câmera negada. Por favor, permita o acesso à câmera e recarregue a página.';\n      } else if (error.name === 'NotFoundError' || error.message.includes('Requested device not found')) {\n        userMessage += 'Nenhuma câmera encontrada. Conecte uma câmera e recarregue a página.';\n      } else if (error.name === 'NotReadableError' || error.message.includes('Could not start video source')) {\n        userMessage += 'Câmera pode estar em uso por outro aplicativo. Feche outros programas que possam estar usando a câmera.';\n      } else if (error.name === 'NotSupportedError') {\n        userMessage += 'Sua câmera não é compatível com os requisitos necessários. Tente usar outra câmera.';\n      } else if (error.message.includes('Timeout')) {\n        userMessage += 'Tempo excedido ao tentar acessar a câmera. Tente recarregar a página.';\n      } else {\n        userMessage += error.message || 'Erro desconhecido ao acessar a câmera.';\n      }\n      \n      console.warn(userMessage);\n      throw error;  // Vamos deixar o StudentView lidar com o erro\n    }\n  }\n\n  simulateDetection() {\n    console.log('Iniciando modo simulado de detecção facial');\n    // Modo simulado para desenvolvimento sem câmera\n    this.simulationInterval = setInterval(() => {\n      const isGazeOnScreen = Math.random() > 0.3; // 70% chance de olhar para tela\n      const fatigueScore = Math.random() * 0.8; // Score de fadiga variável\n      const blinkIncrement = Math.floor(Math.random() * 3); // 0-2 piscadas por intervalo\n\n      this.blinkCount += blinkIncrement;\n\n      this.onDetectionUpdate({\n        faceDetected: true,\n        gazeOnScreen: isGazeOnScreen,\n        fatigueScore: fatigueScore,\n        blinkCount: this.blinkCount,\n        yawnCount: this.yawnCount,\n        attentionScore: isGazeOnScreen ? (1.0 - fatigueScore * 0.5) : 0.0\n      });\n    }, 2000);\n  }\n\n  async stop() {\n    try {\n      if (this.camera) {\n        await this.camera.stop();\n        this.camera = null;\n      }\n      if (this.faceMesh) {\n        await this.faceMesh.close();\n        this.faceMesh = null;\n      }\n      this.isInitialized = false;\n      \n      // Limpar o elemento de vídeo\n      const videoElement = document.getElementById('input_video');\n      if (videoElement) {\n        videoElement.srcObject = null;\n        videoElement.load();\n      }\n      \n      console.log('Sistema de detecção facial parado com sucesso');\n    } catch (error) {\n      console.error('Erro ao parar o sistema:', error);\n    }\n  }\n\n  resetCounters() {\n    this.blinkCount = 0;\n    this.yawnCount = 0;\n    this.gazeOffScreen = 0;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}